var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var _a, _e2, _t2, _b;
function e(e2, s2) {
  if (s2.ok) return s2.value.data;
  if ("SESSION_DESTROYED" === s2.value) throw new Error(`${e2} failed because the session was destroyed`);
  if ("server" === s2.where) throw new Error(t(e2, s2.value));
  throw "unreachable";
}
function t(e2, t2) {
  let s2;
  return s2 = Array.isArray(t2.reasons) ? t2.reasons.join() : JSON.stringify(t2.reasons), `${e2} failed, got status ${t2.status} ${t2.errorCode}, reasons: ${s2}`;
}
function s(e2, t2) {
  if (e2.length !== t2.length) return false;
  for (let s2 = 0; s2 < e2.length; s2++) if ("*" !== t2[s2] && e2[s2] !== t2[s2]) return false;
  return true;
}
function n(e2) {
  return e2 <= 0 ? Promise.resolve() : new Promise((t2) => setTimeout(t2, e2));
}
function r(e2, t2) {
  return e2 * (1 - t2 + 2 * Math.random() * t2);
}
const i = () => true;
function a(_0, _1, _2) {
  return __async(this, arguments, function* (e2, t2, { initialDelay: s2, maxDelay: o2, log: u2, shouldRetry: c2 = i }) {
    return t2().catch((i2) => __async(this, null, function* () {
      if (0 === e2) throw i2;
      if (!(yield c2(i2))) throw i2;
      const l2 = 1e3 * s2 * 1.2, h2 = r(o2 ? Math.min(1e3 * o2, l2) : l2, 0.05);
      return n(h2).then(() => a(e2 - 1, t2, { initialDelay: h2 / 1e3, maxDelay: o2, log: u2, shouldRetry: c2 }));
    }));
  });
}
function o() {
  const e2 = {}, t2 = new Promise(function(t3, s2) {
    e2.resolve = t3, e2.reject = s2;
  });
  return e2.promise = t2, e2;
}
class u {
  constructor(e2, t2, s2) {
    this.layer = e2, this.states = t2, this.transitions = s2, this._state = t2[0];
  }
  get state() {
    return this._state;
  }
  transition(e2) {
    const t2 = this.transitions[e2];
    if (!t2) return;
    if (!this.canTransition(e2)) return;
    const s2 = this.state;
    this._state = t2.to, t2.afterTransition({ from: s2, to: this.state });
  }
  canTransition(e2) {
    const t2 = this.transitions[e2];
    return !!t2 && ("ANY" === t2.from || t2.from.includes(this.state));
  }
}
function c(e2) {
  return { ok: true, value: e2 };
}
function l(e2) {
  return { ok: false, where: "client", value: e2 };
}
function h(e2) {
  return { ok: false, where: "server", value: e2 };
}
function d() {
  const e2 = {}, t2 = new Promise((t3) => {
    e2.ok = (e3) => __async(this, null, function* () {
      return t3(c(e3));
    }), e2.clientErr = (e3) => t3(l(e3)), e2.serverErr = (e3) => t3(h(e3)), e2.resolve = (e3) => t3(e3);
  });
  return e2.promise = t2, e2;
}
let p = null;
function f({ WebSocket: e2 }) {
  p = e2;
}
class m {
  constructor(e2, t2) {
    this.realtimeUrl = e2, this.handlers = t2, this.socket = null, this.stateMachine = new u("ReconnectingSocket", ["STOPPED", "CONNECTING", "READY", "DISCONNECTED", "TERMINATED"], { startWs: { from: ["STOPPED", "DISCONNECTED"], to: "CONNECTING", afterTransition: () => {
      const e3 = new (function() {
        if (p) return p;
        if (globalThis.WebSocket) return globalThis.WebSocket;
        throw new Error("Missing WebSocket implementation");
      }())(this.realtimeUrl + "&talkjs-time=" + Date.now());
      this.socket = e3, e3.addEventListener("open", () => {
        this.socket === e3 && this.stateMachine.transition("onOpen");
      }), e3.addEventListener("close", () => {
        this.socket === e3 && this.stateMachine.transition("onClose");
      }), e3.addEventListener("message", (t3) => {
        this.socket === e3 && this.handlers.onMessage(t3);
      });
    } }, onOpen: { from: ["CONNECTING"], to: "READY", afterTransition: () => {
      this.handlers.onOpen();
    } }, onClose: { from: ["CONNECTING", "READY"], to: "DISCONNECTED", afterTransition: (_0) => __async(this, [_0], function* ({ from: e3 }) {
      "READY" === e3 && this.handlers.onClose(), this.socket = null;
      const t3 = r(1e4, 0.5);
      setTimeout(() => {
        "DISCONNECTED" === this.stateMachine.state && this.stateMachine.transition("startWs");
      }, t3);
    }) }, stopWs: { from: ["CONNECTING", "DISCONNECTED", "READY"], to: "STOPPED", afterTransition: ({ from: e3 }) => {
      "READY" === e3 && this.handlers.onClose();
      const t3 = this.socket;
      this.socket = null, t3 == null ? void 0 : t3.close(1e3);
    } }, destroy: { from: "ANY", to: "TERMINATED", afterTransition: () => {
      const e3 = this.socket;
      this.socket = null, e3 == null ? void 0 : e3.close(1e3);
    } } });
  }
  stopWs() {
    this.stateMachine.transition("stopWs");
  }
  startWs() {
    this.stateMachine.transition("startWs");
  }
  send(e2) {
    return "READY" === this.stateMachine.state ? (this.socket.send(e2), c(void 0)) : l("SOCKET_NOT_READY");
  }
  terminate() {
    const e2 = this.socket;
    this.stateMachine.canTransition("onClose") && this.stateMachine.transition("onClose"), e2 && ("terminate" in e2 ? e2.terminate() : e2.close(1e3));
  }
  destroy() {
    this.stateMachine.transition("destroy");
  }
}
class g {
  constructor(e2, t2) {
    this.handlers = t2, this.socket = new m(e2, { onOpen: () => this.handlers.onOpen(), onClose: () => this.handlers.onClose(), onMessage: (e3) => this.onWebSocketMessage(e3) });
  }
  call(e2, t2, s2, n2) {
    const r2 = `/${s2.map((e3) => encodeURIComponent(e3)).join("/")}`, i2 = JSON.stringify([e2, t2, r2, n2]);
    return this.socket.send(i2);
  }
  stopWs() {
    this.socket.stopWs();
  }
  startWs() {
    this.socket.startWs();
  }
  destroy() {
    this.socket.destroy();
  }
  terminate() {
    this.socket.terminate();
  }
  onWebSocketMessage(e2) {
    if ("Auth token expired" !== e2.data) try {
      const t2 = JSON.parse(e2.data);
      if ("PUBLISH" === t2[1]) {
        const e3 = t2[0], s2 = JSON.stringify([e3, "ACK"]);
        this.socket.send(s2);
        const n2 = t2.slice(2), r2 = [];
        n2.forEach((e4) => {
          "session.expired" === e4.type ? this.handlers.onAuthExpired() : "upstream.restarting" === e4.type ? this.handlers.onUpstreamRestarting() : r2.push(e4);
        }), r2.length > 0 && this.handlers.onPublish(e3, r2);
      } else {
        const e3 = t2[0], s2 = t2[1], n2 = t2[2];
        this.handlers.onResponse(e3, s2, n2);
      }
    } catch (e3) {
    }
    else this.handlers.onAuthExpired();
  }
}
class v {
  constructor(e2) {
    this.delayMs = e2, this.timeout = void 0;
  }
  schedule(e2) {
    this.stop(), this.timeout = setTimeout(() => {
      void 0 !== this.timeout && (this.stop(), e2());
    }, this.delayMs);
  }
  stop() {
    void 0 !== this.timeout && (clearTimeout(this.timeout), this.timeout = void 0);
  }
}
class w {
  constructor() {
    this.i = -1;
  }
  next() {
    return this.i++, this.i;
  }
  reset() {
    this.i = -1;
  }
}
class b {
  constructor(e2, t2) {
    this.handlers = t2, this.seqCounter = new w(), this.responseHandlers = {}, this.heartbeats = new y(this), this.socket = new g(e2, { onUpstreamRestarting: () => {
      this.heartbeats.serverActive(), this.handlers.onUpstreamRestarting();
    }, onOpen: () => {
      this.heartbeats.clientActive(), this.heartbeats.serverActive(), this.handlers.onReady();
    }, onClose: () => {
      this.heartbeats.stop(), Object.values(this.responseHandlers).forEach((e3) => {
        e3.clientErr("WEBSOCKET_DISCONNECTED");
      }), this.responseHandlers = {}, this.seqCounter.reset(), this.handlers.onNotReady();
    }, onResponse: (e3, t3, s2) => {
      this.heartbeats.serverActive(), this.onResponse(e3, t3, s2);
    }, onPublish: (e3, t3) => {
      this.heartbeats.serverActive(), this.handlers.onPublish(e3, t3), this.heartbeats.clientActive();
    }, onAuthExpired: () => {
      this.heartbeats.serverActive(), this.handlers.onAuthExpired();
    } });
  }
  call(e2, t2, s2) {
    const n2 = this.seqCounter.next(), r2 = d();
    this.responseHandlers[n2] = r2;
    const i2 = this.socket.call(n2, e2, t2, s2);
    return i2.ok || r2.resolve(i2), this.heartbeats.clientActive(), r2.promise;
  }
  onResponse(e2, t2, s2) {
    return __async(this, null, function* () {
      const n2 = this.responseHandlers[e2];
      n2 && (200 === t2 ? n2.ok({ status: t2, data: s2 }) : n2.serverErr({ status: t2, errorCode: s2.errorCode, reasons: s2.reasons }), delete this.responseHandlers[e2]);
    });
  }
  stopWs() {
    this.socket.stopWs();
  }
  startWs() {
    this.socket.startWs();
  }
  destroy() {
    this.heartbeats.stop(), Object.values(this.responseHandlers).forEach((e2) => {
      e2.clientErr("WEBSOCKET_DISCONNECTED");
    }), this.responseHandlers = {}, this.socket.destroy();
  }
  terminate() {
    this.socket.terminate();
  }
}
class y {
  constructor(e2) {
    this.connection = e2, this.clientInactivityTimer = new v(25e3), this.serverInactivityTimer = new v(1e4), this.serverTimeoutTimer = new v(5e3);
  }
  clientActive() {
    this.clientInactivityTimer.schedule(() => {
      this.sendHeartbeat();
    });
  }
  serverActive() {
    this.serverTimeoutTimer.stop(), this.serverInactivityTimer.schedule(() => {
      this.sendHeartbeat(), this.serverTimeoutTimer.schedule(() => {
        this.connection.terminate();
      });
    });
  }
  stop() {
    this.clientInactivityTimer.stop(), this.serverInactivityTimer.stop(), this.serverTimeoutTimer.stop();
  }
  sendHeartbeat() {
    this.connection.call("GET", ["ping"], {}).catch(() => {
    });
  }
}
class C {
  constructor(e2, t2, s2) {
    this.authProvider = t2, this.handlers = s2, this.stateMachine = new u("AuthenticatedConnection", ["WAITING_FOR_WS", "LOGGING_IN", "RENEWING_SESSION", "READY", "TERMINATED"], { logIn: { from: ["WAITING_FOR_WS"], to: "LOGGING_IN", afterTransition: () => __async(this, null, function* () {
      yield this.renewSession();
    }) }, logInFailed: { from: ["LOGGING_IN"], to: "LOGGING_IN", afterTransition: () => __async(this, null, function* () {
      this.authProvider.refreshToken(), yield this.renewSession();
    }) }, scheduledReauth: { from: ["READY"], to: "RENEWING_SESSION", afterTransition: () => __async(this, null, function* () {
      yield this.renewSession();
    }) }, scheduledReauthFailed: { from: ["RENEWING_SESSION"], to: "RENEWING_SESSION", afterTransition: () => __async(this, null, function* () {
      this.authProvider.refreshToken(), yield this.renewSession();
    }) }, authenticated: { from: ["LOGGING_IN", "RENEWING_SESSION"], to: "READY", afterTransition: ({ from: e3 }) => {
      "LOGGING_IN" === e3 && this.handlers.onReady();
    } }, authExpired: { from: ["READY", "RENEWING_SESSION"], to: "LOGGING_IN", afterTransition: () => __async(this, null, function* () {
      this.handlers.onNotReady(), this.authProvider.refreshToken(), yield this.renewSession();
    }) }, wsDisconnected: { from: ["READY", "LOGGING_IN", "RENEWING_SESSION"], to: "WAITING_FOR_WS", afterTransition: ({ from: e3 }) => {
      "READY" !== e3 && "RENEWING_SESSION" !== e3 || this.handlers.onNotReady(), this.authProvider.clearScheduledRefresh();
    } }, destroy: { from: "ANY", to: "TERMINATED", afterTransition: () => {
      this.authProvider.clearScheduledRefresh(), this.connection.destroy();
    } } }), this.connection = new b(e2, { onUpstreamRestarting: () => this.handlers.onUpstreamRestarting(), onReady: () => this.stateMachine.transition("logIn"), onNotReady: () => {
      this.stateMachine.transition("wsDisconnected");
    }, onAuthExpired: () => {
      this.stateMachine.transition("authExpired");
    }, onPublish: (e3, t3) => {
      this.handlers.onPublish(e3, t3);
    } }), t2.onTokenChanged(() => {
      "READY" === this.stateMachine.state && this.stateMachine.transition("scheduledReauth");
    });
  }
  call(e2, t2, s2) {
    const n2 = this.connection.call(e2, t2, s2);
    return n2.then((e3) => {
      e3.ok || "server" !== e3.where || 401 !== e3.value.status || "READY" !== this.stateMachine.state && "RENEWING_SESSION" !== this.stateMachine.state || this.stateMachine.transition("authExpired");
    }), n2;
  }
  stopWs() {
    this.connection.stopWs();
  }
  startWs() {
    this.connection.startWs();
  }
  destroy() {
    this.stateMachine.transition("destroy");
  }
  renewSession() {
    return __async(this, null, function* () {
      const e2 = yield this.authProvider.getToken(), s2 = yield this.connection.call("POST", ["session", "renew"], { token: e2 });
      if (!s2.ok && "client" === s2.where) return;
      const n2 = s2.value;
      if (n2.status, 200 === n2.status) {
        const t2 = n2.data.expiresInSeconds;
        return void (null !== t2 && t2 < 120 ? (console.warn(`[TalkJS] Authenticated with a token that expires in ${t2}s. Treating it as already expired and refreshing. Newly generated tokens should last at least 10 minutes.`), "LOGGING_IN" === this.stateMachine.state ? this.stateMachine.transition("logInFailed") : "RENEWING_SESSION" === this.stateMachine.state && this.stateMachine.transition("scheduledReauthFailed")) : (this.authProvider.scheduleRefresh(t2), this.authProvider.emitTokenAccepted(e2), this.stateMachine.canTransition("authenticated") && this.stateMachine.transition("authenticated")));
      }
      if (401 === n2.status) return void ("LOGGING_IN" === this.stateMachine.state ? this.stateMachine.transition("logInFailed") : "RENEWING_SESSION" === this.stateMachine.state && this.stateMachine.transition("scheduledReauthFailed"));
      if (400 === n2.status) return void this.authProvider.emitTokenRefreshFailed(t("Authentication", n2));
      if (402 === n2.status) return void this.authProvider.emitTokenRefreshFailed(t("Authentication", n2));
      const r2 = 5e3 * Math.random() + 5e3;
      setTimeout(() => {
        this.call("POST", ["session", "renew"], { token: e2 }).catch(() => {
        });
      }, r2);
    });
  }
}
class A {
  constructor(e2, t2, s2) {
    this.handlers = s2, this.stateMachine = new u("StopStartConnection", ["STOPPED", "WAITING_FOR_WS", "READY", "TERMINATED"], { unexpectedDisconnect: { from: ["READY"], to: "WAITING_FOR_WS", afterTransition: () => {
      this.inactivityTimer.stop(), this.handlers.onNotReady();
    } }, stop: { from: ["WAITING_FOR_WS", "READY"], to: "STOPPED", afterTransition: () => {
      this.connection.stopWs(), this.inactivityTimer.stop(), this.handlers.onNotReady();
    } }, start: { from: ["STOPPED"], to: "WAITING_FOR_WS", afterTransition: () => {
      this.connection.startWs();
    } }, ready: { from: ["WAITING_FOR_WS"], to: "READY", afterTransition: () => {
      this.pendingCalls = 0, this.activeSubscriptions = 0, this.inactivityTimer.schedule(() => {
        this.stateMachine.transition("stop");
      }), this.handlers.onReady();
    } }, destroy: { from: "ANY", to: "TERMINATED", afterTransition: () => {
      this.inactivityTimer.stop(), this.connection.destroy();
    } } }), this.pendingCalls = 0, this.activeSubscriptions = 0, this.inactivityTimer = new v(3e3), this.connection = new C(e2, t2, { onUpstreamRestarting: () => {
      this.handlers.onUpstreamRestarting();
    }, onReady: () => {
      this.stateMachine.transition("ready");
    }, onNotReady: () => {
      "READY" === this.stateMachine.state && this.stateMachine.transition("unexpectedDisconnect");
    }, onPublish: (e3, t3) => {
      this.handlers.onPublish(e3, t3);
    } });
  }
  get inactive() {
    return 0 === this.pendingCalls && 0 === this.activeSubscriptions;
  }
  ensureStarted() {
    this.stateMachine.canTransition("start") && this.stateMachine.transition("start");
  }
  call(e2, t2, s2) {
    return __async(this, null, function* () {
      this.inactivityTimer.stop(), this.pendingCalls++, this.logTrace("Called", t2, s2);
      const n2 = yield this.connection.call(e2, t2, s2);
      return this.pendingCalls--, this.logTrace("Received", t2, s2), "SUBSCRIBE" === e2 && n2.ok ? (this.activeSubscriptions++, this.logTrace("Subscribed", t2, s2)) : "UNSUBSCRIBE" === e2 && n2.ok && (this.activeSubscriptions--, this.logTrace("Unsubscribed", t2, s2)), this.inactive && this.inactivityTimer.schedule(() => {
        this.stateMachine.transition("stop");
      }), n2;
    });
  }
  destroy() {
    this.stateMachine.transition("destroy");
  }
  isConnected() {
    return "READY" === this.stateMachine.state;
  }
  logTrace(e2, t2, s2) {
  }
}
class E {
  constructor(e2, t2, s2) {
    this.handlers = s2, this.stateMachine = new u("QueuedConnection", ["NOT_READY", "PROCESSING_QUEUE", "READY", "TERMINATED"], { processQueue: { from: ["NOT_READY"], to: "PROCESSING_QUEUE", afterTransition: () => {
      this.sendQueuedCalls();
    } }, ready: { from: ["PROCESSING_QUEUE"], to: "READY", afterTransition: () => {
      this.handlers.onReady();
    } }, notReady: { from: ["PROCESSING_QUEUE", "READY"], to: "NOT_READY", afterTransition: () => {
      Object.values(this.subscribeQueue).forEach((e3) => e3.deferred.ok({ status: 200, data: {} })), this.subscribeQueue = {}, this.handlers.onSubscriptionsLost();
    } }, destroy: { from: "ANY", to: "TERMINATED", afterTransition: () => {
      var _a2;
      for (; this.callQueue.length; ) {
        const e3 = (_a2 = this.callQueue.shift()) == null ? void 0 : _a2.deferred;
        e3 == null ? void 0 : e3.clientErr("SESSION_DESTROYED");
      }
      this.connection.destroy();
    } } }), this.subscribeQueue = {}, this.callQueue = [], this.connection = new A(e2, t2, { onUpstreamRestarting: () => {
      this.handlers.onUpstreamRestarting();
    }, onReady: () => {
      this.stateMachine.transition("processQueue");
    }, onNotReady: () => {
      this.stateMachine.transition("notReady");
    }, onPublish: (e3, t3) => {
      this.handlers.onPublish(e3, t3);
    } });
  }
  call(e2, t2, s2) {
    return "READY" === this.stateMachine.state ? this.connection.call(e2, t2, s2) : ("NOT_READY" === this.stateMachine.state && this.connection.ensureStarted(), "SUBSCRIBE" === e2 || "UNSUBSCRIBE" === e2 ? this._subscribe(e2, t2, s2) : this._call(e2, t2, s2));
  }
  _subscribe(e2, t2, s2) {
    const n2 = t2.join("/"), r2 = this.subscribeQueue[n2];
    if (r2 && r2.method === e2) return r2.deferred.promise;
    r2 && r2.method !== e2 && (r2.deferred.ok({ status: 200, data: {} }), delete this.subscribeQueue[n2]);
    const i2 = { deferred: d(), method: e2, path: t2, data: s2 };
    return this.subscribeQueue[n2] = i2, i2.deferred.promise;
  }
  _call(e2, t2, s2) {
    const n2 = { deferred: d(), method: e2, path: t2, data: s2 };
    return this.callQueue.push(n2), n2.deferred.promise;
  }
  dequeue() {
    for (const e2 in this.subscribeQueue) {
      const t2 = this.subscribeQueue[e2];
      return delete this.subscribeQueue[e2], t2;
    }
    return this.callQueue.shift();
  }
  destroy() {
    this.stateMachine.transition("destroy");
  }
  sendQueuedCalls() {
    return __async(this, null, function* () {
      let e2 = 0;
      for (; "PROCESSING_QUEUE" === this.stateMachine.state; ) {
        e2++;
        const t2 = this.dequeue();
        if (!t2) return void this.stateMachine.transition("ready");
        this.connection.call(t2.method, t2.path, t2.data).then((e3) => {
          t2.deferred.resolve(e3);
        }), e2 > 50 && (yield new Promise((e3) => setTimeout(e3, 100)));
      }
    });
  }
  isConnected() {
    return "READY" === this.stateMachine.state || "PROCESSING_QUEUE" === this.stateMachine.state;
  }
}
const k = "undefined" != typeof window ? (_a = window.queueMicrotask) != null ? _a : setTimeout : setTimeout;
class x {
  constructor(e2, t2) {
    this.clearPendingBatch = e2, this.sendCalls = t2, this.sent = false, k(() => this.send());
  }
  send() {
    this.sent || (this.sent = true, this.clearPendingBatch(), this.sendCalls());
  }
  destroy() {
    this.sent = true;
  }
}
class I extends x {
  constructor(e2, t2) {
    super(t2, () => {
      this.sendSubscribe(), this.sendGet();
    }), this.connection = e2, this.getCalls = [], this.subscribeCalls = [];
  }
  canPush(e2, t2) {
    return I.isCorrectBatchTypeFor(e2, t2);
  }
  static isCorrectBatchTypeFor(e2, t2) {
    return s(t2, ["users", "*"]) && ("GET" === e2 || "SUBSCRIBE" === e2);
  }
  push(e2, t2, s2) {
    const n2 = t2[1], r2 = d();
    return "GET" === e2 ? this.getCalls.push({ userId: n2, deferred: r2 }) : this.subscribeCalls.push({ userId: n2, deferred: r2 }), 1e3 !== this.getCalls.length && 1e3 !== this.subscribeCalls.length || this.send(), r2.promise;
  }
  sendGet() {
    return __async(this, null, function* () {
      if (0 === this.getCalls.length) return;
      const e2 = [...new Set(this.getCalls.map((e3) => e3.userId))], t2 = yield this.connection.call("GET", ["users"], { ids: e2, includePrivateFields: false });
      if (t2.ok) for (const e3 of this.getCalls) {
        const s2 = t2.value.data[e3.userId];
        s2 ? e3.deferred.ok({ status: 200, data: s2 }) : e3.deferred.serverErr({ status: 404, errorCode: "NOT_FOUND", reasons: ["No user with that ID exists"] });
      }
      else this.getCalls.forEach((e3) => e3.deferred.resolve(t2));
    });
  }
  sendSubscribe() {
    if (0 === this.subscribeCalls.length) return;
    const e2 = [...new Set(this.subscribeCalls.map((e3) => e3.userId))];
    this.connection.call("SUBSCRIBE", ["users"], { ids: e2 }).then((e3) => this.subscribeCalls.forEach((t2) => t2.deferred.resolve(e3)));
  }
}
class T extends x {
  constructor(e2, t2, s2) {
    super(s2, () => this.sendMutate()), this.conversationId = e2, this.connection = t2, this.calls = [];
  }
  canPush(e2, t2) {
    return !!T.isCorrectBatchTypeFor(e2, t2) && t2[1] === this.conversationId;
  }
  static isCorrectBatchTypeFor(e2, t2) {
    return s(t2, ["conversations", "*", "participants", "*"]) && ("PUT" === e2 || "POST" === e2 || "PATCH" === e2);
  }
  push(e2, t2, s2) {
    const n2 = t2[3], r2 = d();
    return this.calls.push({ action: { id: n2, method: e2, params: s2 }, deferred: r2 }), 100 === this.calls.length && this.send(), r2.promise;
  }
  sendMutate() {
    return __async(this, null, function* () {
      const e2 = this.calls.map((e3) => e3.action), t2 = yield this.connection.call("POST", ["conversations", this.conversationId, "participants"], { actions: e2 });
      if (!t2.ok) return void this.calls.forEach((e3) => e3.deferred.resolve(t2));
      const s2 = t2.value.data.responses;
      for (let e3 = 0; e3 < s2.length; e3++) {
        const t3 = this.calls[e3].deferred, n2 = s2[e3];
        200 === n2.status ? t3.ok(__spreadProps(__spreadValues({}, n2), { data: {} })) : t3.serverErr(n2);
      }
    });
  }
}
class D {
  constructor(e2, t2, s2) {
    this.pendingBatch = null, this.connection = new E(e2, t2, s2);
  }
  call(e2, t2, s2) {
    return __async(this, null, function* () {
      var _a2;
      if ((_a2 = this.pendingBatch) == null ? void 0 : _a2.canPush(e2, t2)) return this.pendingBatch.push(e2, t2, s2);
      this.pendingBatch && this.pendingBatch.send();
      const n2 = this.createEmptyBatchFor(e2, t2);
      return n2 ? (this.pendingBatch = n2, n2.push(e2, t2, s2)) : this.connection.call(e2, t2, s2);
    });
  }
  destroy() {
    var _a2;
    this.connection.destroy(), (_a2 = this.pendingBatch) == null ? void 0 : _a2.destroy();
  }
  isConnected() {
    return this.connection.isConnected();
  }
  createEmptyBatchFor(e2, t2) {
    if (I.isCorrectBatchTypeFor(e2, t2)) return new I(this.connection, () => this.pendingBatch = null);
    if (T.isCorrectBatchTypeFor(e2, t2)) {
      const e3 = t2[1];
      return new T(e3, this.connection, () => this.pendingBatch = null);
    }
    return null;
  }
}
const S = { 200: "RESOLVE", 400: "RESOLVE", 401: "RETRY", 402: "RESOLVE", 403: "RESOLVE", 404: "RESOLVE", 405: "RESOLVE", 409: "RESOLVE", 429: "DELAY", 500: "DELAY" };
class M {
  constructor(e2, t2, s2) {
    this.throttler = new F(), this.alive = true, this.connection = new D(e2, t2, s2);
  }
  call(e2, t2, s2) {
    return __async(this, null, function* () {
      let n2 = 0;
      for (; this.alive; ) {
        const r2 = yield this.connection.call(e2, t2, s2);
        if ((r2.ok || "client" !== r2.where || "SOCKET_NOT_READY" !== r2.value) && (r2.ok || "server" !== r2.where || 500 !== r2.value.status) || n2++, 10 === n2) return r2;
        if (r2.ok || "client" !== r2.where) {
          const e3 = r2.value, t3 = e3.status, s3 = S[t3];
          if ("RESOLVE" === s3) return this.throttler.resetDelay(), r2;
          if ("RETRY" === s3) continue;
          if ("DELAY" === s3) {
            yield this.throttler.wait();
            continue;
          }
          return console.warn("[TalkJS] Unexpected status code", t3), e3;
        }
        if ("SESSION_DESTROYED" === r2.value) return l("SESSION_DESTROYED");
        "WEBSOCKET_DISCONNECTED" !== r2.value && ("SOCKET_NOT_READY" !== r2.value ? r2.value : yield this.throttler.wait());
      }
      return l("SESSION_DESTROYED");
    });
  }
  destroy() {
    this.alive = false, this.connection.destroy();
  }
  isConnected() {
    return this.connection.isConnected();
  }
}
class F {
  constructor() {
    this.initialDelayMs = 200, this.exponentialFactor = 1.2, this.maxDelayMs = 3e4, this.currentDelayMs = this.initialDelayMs, this.lastCall = 0;
  }
  getCurrentDelay() {
    return this.currentDelayMs;
  }
  wait() {
    const e2 = (/* @__PURE__ */ new Date()).getTime(), t2 = r(this.currentDelayMs, 0.05), s2 = this.lastCall + t2, i2 = Math.max(0, s2 - e2);
    return this.lastCall = e2 + i2, this.currentDelayMs = Math.min(t2 * this.exponentialFactor, this.maxDelayMs), n(i2);
  }
  resetDelay() {
    this.currentDelayMs = this.initialDelayMs;
  }
}
function B(e2) {
  return e2.map((e3) => encodeURIComponent(e3)).join();
}
class R {
  constructor() {
    this.paths = {};
  }
  add(e2) {
    this.paths[B(e2)] = e2;
  }
  delete(e2) {
    delete this.paths[B(e2)];
  }
  has(e2) {
    return Object.hasOwnProperty.call(this.paths, B(e2));
  }
  clear() {
    this.paths = {};
  }
  forEach(e2) {
    Object.values(this.paths).forEach((t2) => e2(t2));
  }
}
class N {
  constructor(e2, t2, s2) {
    this.handlers = s2, this.targetSubscriptions = new R(), this.connection = new M(e2, t2, { onUpstreamRestarting: () => this.handlers.onUpstreamRestarting(), onSubscriptionsLost: () => {
      this.targetSubscriptions.forEach((e3) => {
        this.resubscribe(e3);
      }), this.handlers.onResubscribeSent();
    }, onReady: () => this.handlers.onReady(), onPublish: (e3, t3) => {
      this.handlers.onPublish(e3, t3);
    } });
  }
  call(e2, t2, s2) {
    return this.connection.call(e2, t2, s2);
  }
  subscribe(e2) {
    return __async(this, null, function* () {
      return this.targetSubscriptions.add(e2), this.connection.call("SUBSCRIBE", e2, {});
    });
  }
  unsubscribe(e2) {
    return __async(this, null, function* () {
      return this.targetSubscriptions.delete(e2), this.connection.call("UNSUBSCRIBE", e2, {});
    });
  }
  resubscribe(e2) {
    return __async(this, null, function* () {
      const t2 = yield this.connection.call("SUBSCRIBE", e2, {});
      t2.ok || this.handlers.onResubscribeError(e2, t2);
    });
  }
  destroy() {
    this.targetSubscriptions.clear(), this.connection.destroy();
  }
  isConnected() {
    return this.connection.isConnected();
  }
}
function _(e2) {
  return Object.freeze(e2);
}
function P(e2) {
  return _(e2.map((e3) => function(e4) {
    switch (e4.type) {
      case "text":
        return Object.freeze({ type: "text", children: O(e4.children) });
      case "file":
      case "location":
        return Object.freeze(e4);
    }
  }(e3)));
}
function O(e2) {
  return _(e2.map((e3) => function(e4) {
    if ("string" == typeof e4) return e4;
    switch (e4.type) {
      case "bold":
      case "italic":
      case "strikethrough":
      case "bulletList":
      case "bulletPoint":
      case "link":
      case "actionLink":
      case "actionButton":
        return Object.freeze(__spreadProps(__spreadValues({}, e4), { children: O(e4.children) }));
      case "mention":
      case "autoLink":
      case "codeSpan":
      case "customEmoji":
        return Object.freeze(e4);
    }
  }(e3)));
}
function j(e2, t2) {
  return void 0 === t2 ? e2 : t2;
}
function U(e2, t2) {
  return void 0 === t2 ? e2 : _(t2);
}
function $(e2, t2) {
  if (void 0 === t2) return e2;
  if (null === t2) return _({});
  const s2 = __spreadValues({}, e2);
  for (const e3 in t2) {
    const n2 = t2[e3];
    null === n2 ? delete s2[e3] : s2[e3] = n2;
  }
  return _(s2);
}
function W(e2, t2) {
  if (e2 === t2) return true;
  if (!e2 || !t2) return false;
  if ("object" != typeof e2 || "object" != typeof t2) return false;
  if (e2.constructor !== t2.constructor) return false;
  if (Array.isArray(e2) && Array.isArray(t2)) {
    if (e2.length !== t2.length) return false;
    for (let s2 = 0; s2 < e2.length; s2++) if (!W(e2[s2], t2[s2])) return false;
  } else {
    const s2 = Object.keys(e2);
    if (s2.length !== Object.keys(t2).length) return false;
    for (const n2 of s2) {
      if (!Object.hasOwnProperty.call(t2, n2)) return false;
      if (!W(e2[n2], t2[n2])) return false;
    }
  }
  return true;
}
class q {
  constructor() {
    this.prev = Promise.resolve();
  }
  runExclusive(e2) {
    return __async(this, null, function* () {
      const t2 = this.prev.then(() => e2());
      return this.prev = t2, t2;
    });
  }
}
class H {
  constructor(e2) {
    this.initialised = false, this.getPointer = void 0, this.pendingStates = [e2], e2.resultPromise.then(() => this.initialised = true);
  }
  get pendingPointer() {
    if (0 !== this.pendingStates.length) return this.pendingStates[this.pendingStates.length - 1];
  }
  get mostRecentState() {
    var _a2;
    return (_a2 = this.pendingPointer) != null ? _a2 : this.getPointer;
  }
  canAppendState(e2) {
    var _a2, _b2;
    const t2 = (_a2 = this.getPointer) == null ? void 0 : _a2.seq;
    if (void 0 !== t2 && e2 <= t2) return false;
    const s2 = (_b2 = this.pendingPointer) == null ? void 0 : _b2.seq;
    return !(void 0 !== s2 && e2 < s2);
  }
  set(e2) {
    if (!this.canAppendState(e2.seq)) throw "Appending in the past";
    this.pendingStates.push(e2);
  }
  mutate(e2, t2) {
    if (!this.initialised) return;
    if (!this.canAppendState(e2)) throw "Mutating in the past";
    const s2 = this.mostRecentState.resultPromise.then((e3) => e3.ok ? t2(e3) : e3);
    this.pendingStates.push({ seq: e2, resultPromise: s2 });
  }
  get(e2) {
    for (; this.pendingStates.length > 0 && (void 0 === this.getPointer || this.pendingStates[0].seq <= e2); ) this.getPointer = this.pendingStates.shift();
    return this.getPointer;
  }
}
class L extends H {
  constructor(e2, t2) {
    super(e2), this.onTeardown = t2, this._error = null, this._lastGoodState = Promise.resolve(void 0), this.registerNewState(e2.resultPromise);
  }
  get error() {
    return this._error;
  }
  get lastGoodState() {
    return this._lastGoodState;
  }
  mutate(e2, t2) {
    super.mutate(e2, t2), this.registerNewState(this.mostRecentState.resultPromise);
  }
  set(e2) {
    super.set(e2), this.registerNewState(this.mostRecentState.resultPromise);
  }
  registerNewState(e2) {
    const t2 = this.lastGoodState;
    this._lastGoodState = e2.then((e3) => e3.ok ? e3.value : t2), e2.then((e3) => {
      e3.ok || this.setError(e3);
    });
  }
  setError(e2) {
    var _a2;
    this._error || (this._error = e2, (_a2 = this.onTeardown) == null ? void 0 : _a2.call(this, e2), this.lastGoodState.then((e3) => {
      void 0 !== e3 && this.teardownNested(e3);
    }));
  }
}
class G extends L {
  constructor(e2, t2) {
    const s2 = new Promise((e3) => setTimeout(e3)).then(() => this.fetchInitial(e2));
    super({ seq: e2, resultPromise: s2 }, t2.onTeardown), this.initialSeq = e2, this.getDeepMutex = new q(), this.lastDeep = void 0;
  }
  refetchInitial(e2) {
    return __async(this, null, function* () {
      const t2 = this.mostRecentState.resultPromise, s2 = this.fetchInitial(e2), [n2, r2] = yield Promise.all([t2, s2]);
      if (void 0 === n2 || !n2.ok) return r2;
      if (!r2.ok) return r2;
      return this.equal(n2.value, r2.value) ? n2 : r2;
    });
  }
  refetch(e2) {
    if (null !== this.error) return;
    const t2 = { seq: e2, resultPromise: this.refetchInitial(e2) };
    this.set(t2);
  }
  changedBetween(e2, t2) {
    return __async(this, null, function* () {
      if (e2 >= t2) return false;
      const s2 = this.get(t2), n2 = yield s2.resultPromise;
      if (!n2.ok) return false;
      if (n2.value.lastChanged > Math.max(this.initialSeq, e2) && n2.value.lastChanged <= t2) return true;
      return yield this.anyChildChanged(e2, t2, n2.value);
    });
  }
  getDeep(e2) {
    return __async(this, null, function* () {
      return this.getDeepMutex.runExclusive(() => __async(this, null, function* () {
        var _a2;
        if (null !== this.error) return this.error;
        const t2 = (_a2 = this.lastDeep) == null ? void 0 : _a2.seq;
        if (e2 === t2) return this.lastDeep.deep;
        if (void 0 !== t2) {
          if (e2 < t2) throw `Trying to load seq ${e2} when we have previously loaded seq ${t2}`;
          if (!(yield this.changedBetween(t2, e2))) return this.lastDeep.seq = e2, this.lastDeep.deep;
        }
        const s2 = this.get(e2).resultPromise, n2 = s2.then((t3) => t3.ok ? this.loadNested(e2, t3.value) : t3);
        this.lastDeep = { seq: e2, shallow: s2, deep: n2 };
        const r2 = yield n2;
        return r2.ok || this.setError(r2), r2;
      }));
    });
  }
}
class z extends G {
  constructor(e2, t2, s2) {
    super(e2, s2), this.emitMutex = t2, this.unsubscribeTimer = new J(), this.referencedByOtherStores = 0, this.listeners = [], this.lastEmitSeq = void 0, this.lastEmitResult = void 0, t2.runExclusive(() => __async(this, null, function* () {
      yield this.emit(e2);
    }));
  }
  registerInternalSubscription() {
    this.referencedByOtherStores++;
    let e2 = true;
    return () => {
      e2 && (e2 = false, this.referencedByOtherStores--, this.startUnsubscribeTimerIfOrphan());
    };
  }
  get onlyUsedInternally() {
    return 0 === this.listeners.length;
  }
  listen(e2) {
    return this.unsubscribeTimer.stop(), this.listeners.push(e2), void 0 !== this.lastEmitResult && e2(this.lastEmitResult), () => {
      this.listeners = this.listeners.filter((t2) => t2 !== e2), this.startUnsubscribeTimerIfOrphan();
    };
  }
  startUnsubscribeTimerIfOrphan() {
    0 === this.referencedByOtherStores && 0 === this.listeners.length && this.unsubscribeTimer.restart(() => {
      this.setError(l("UNSUBSCRIBED"));
    }, this.unsubscribeDebounceMs);
  }
  emit(e2) {
    return __async(this, null, function* () {
      var _a2;
      if (this.lastEmitSeq && this.lastEmitSeq >= e2) return;
      if (false === ((_a2 = this.lastEmitResult) == null ? void 0 : _a2.ok)) return;
      this.lastEmitSeq = e2;
      const t2 = yield this.getDeep(e2);
      t2 !== this.lastEmitResult && (this.lastEmitResult = t2, this.listeners.forEach((e3) => e3(t2)));
    });
  }
}
class J {
  constructor() {
    this.timerId = void 0;
  }
  restart(e2, t2) {
    void 0 !== this.timerId && clearTimeout(this.timerId), this.timerId = setTimeout(() => e2(), t2);
  }
  stop() {
    clearTimeout(this.timerId);
  }
}
var Y, Q = {};
!function() {
  if (Y) return Q;
  function e2(e3) {
    return String.fromCharCode(parseInt(e3.slice(1), 16));
  }
  function t2(e3) {
    return `%${`00${e3.charCodeAt(0).toString(16)}`.slice(-2)}`;
  }
  Y = 1, Object.defineProperty(Q, "__esModule", { value: true }), Q.encode = function(t3) {
    return btoa(encodeURIComponent(t3).replace(/%[0-9A-F]{2}/g, e2));
  }, Q.decode = function(e3) {
    return decodeURIComponent(Array.from(atob(e3), t2).join(""));
  };
}();
function V(e2, t2) {
  const s2 = t2.lastIndex;
  let n2;
  const r2 = [];
  for (; null !== (n2 = t2.exec(e2)); ) r2.push(n2);
  return t2.lastIndex = s2, r2;
}
function Z(e2) {
  const t2 = e2.replace(/%2F/g, "/").replace(/^.*?\/([^/]+?)(?:\?.*)?$/, "$1");
  return decodeURIComponent(t2);
}
function K(e2, t2) {
  if (!e2() && !t2) {
    t2 = e2.toString().replace(/^function\s*\(\)\s*\{\s*return\s*(.*);\s*\}\s*$/, "`$1`") + " was not true";
  }
}
((e2) => {
  function t2(e3) {
  }
  function s2(e3, t3) {
    (function(e4, t4) {
      switch (t4) {
        case "undefined":
          return void 0 === e4;
        case String:
          return "string" == typeof e4 || e4 instanceof String;
        case Boolean:
          return "boolean" == typeof e4 || e4 instanceof Boolean;
        case Number:
          return "number" == typeof e4 || e4 instanceof Number;
        default:
          return e4 instanceof t4;
      }
    })(e3, t3) || (t3.name, String(e3));
  }
  e2.defined = t2, e2.has = function(e3, t3) {
    e3[t3];
  }, e2.is = s2, e2.equals = function(e3, t3) {
  }, e2.oneOf = function(e3, t3) {
    t3.includes(e3) || JSON.stringify(t3);
  }, e2.isArray = function(e3, t3) {
    s2(e3, Array), e3 && e3.length > 0 && s2(e3[0], t3);
  }, e2.optional = function(e3, t3) {
    void 0 !== e3 && s2(e3, t3);
  }, e2.falsy = function(e3) {
  }, e2.never = function(e3) {
  };
})(K || (K = {}));
const X = K, ee = /^\/.*[^\\]\/[im]*$/;
function te(e2) {
  if (!ee.test(e2)) return false;
  return !se(e2).test("");
}
function se(e2) {
  const t2 = e2.match(/^\/(.*[^\\])\/(.*)$/);
  if (!t2) throw new Error(`Expected ${e2} to be a (non-empty) regex`);
  let s2 = t2[2] || "";
  return s2 = s2.replace(/[^im]/g, "") + "g", new RegExp(t2[1], s2);
}
class ne {
  constructor({ mode: e2, allowedHostnames: t2, allowedPhoneNrs: s2, allowedMatches: n2, forbiddenMatches: r2, suppressLinks: i2, suppressEmailAddresses: a2, suppressPhoneNumbers: o2, replacement: u2 }) {
    X.oneOf(e2, ["all", "otherOnly", "off"]), this.mode = e2, this.suppressLinks = false !== i2, this.suppressEmailAddresses = false !== a2, this.suppressPhoneNumbers = false !== o2, this.allowedHostnames = t2 || [], this.allowedPhoneNrs = (s2 || []).filter((e3) => e3).map((e3) => e3.replace(/[^0-9]/g, "")), this.allowedMatches = (n2 || []).filter(te).map((e3) => se(e3)), this.forbiddenMatches = (r2 || []).filter(te).map((e3) => se(e3)), X(() => this.allowedMatches.every((e3) => e3.flags.includes("g")), "All regexes in `suppressContactInfo.allowedMatches` must be global. Check `allowedMatches`!"), X(() => this.forbiddenMatches.every((e3) => e3.flags.includes("g")), "All regexes in `suppressContactInfo.forbiddenMatches` must be global. Check `forbiddenMatches`!"), u2 = u2 == null ? void 0 : u2.trim(), this.replacement = u2 && u2.length > 0 ? u2 : void 0;
  }
  shouldSuppress({ isContentBySender: e2 }) {
    return "all" === this.mode || "otherOnly" === this.mode && !e2;
  }
}
function re(e2, t2) {
  const s2 = e2.map((e3) => function(e4, t3) {
    if ("text" === e4.type) return function(e5, t4) {
      const s3 = function(e6) {
        var _a2, _b2, _c, _d, _e3, _f, _g, _h, _i, _j, _k, _l, _m;
        let t5 = "";
        return e6.t && (t5 = `(${e6.t("CONTACT_INFORMATION_HIDDEN")})`), { formattedLinks: (_a2 = e6.formattedLinks) != null ? _a2 : "plaintext", markup: (_b2 = e6.markup) != null ? _b2 : false, useFallbackMentions: (_c = e6.useFallbackMentions) != null ? _c : false, sameTabLinkRules: (_d = e6.sameTabLinkRules) != null ? _d : [], enableEmojiImageFallback: (_e3 = e6.enableEmojiImageFallback) != null ? _e3 : false, highlight: (_f = e6.highlight) != null ? _f : [], contactInfo: (_g = e6.contactInfo) != null ? _g : false, suppression: (_h = e6.suppression) != null ? _h : new ne({ mode: "off" }), contactInfoHiddenText: (_k = (_j = e6.contactInfoHiddenText) != null ? _j : (_i = e6.suppression) == null ? void 0 : _i.replacement) != null ? _k : t5, customEmojiUrls: (_l = e6.customEmojiUrls) != null ? _l : {}, enableActions: (_m = e6.enableActions) != null ? _m : true };
      }(t4);
      return ie(e5, s3);
    }(e4.children, t3);
    if ("file" === e4.type && "video" === e4.subtype) return `ðŸŽ¥ ${Z(e4.url)}`;
    if ("file" === e4.type && "image" === e4.subtype) return `ðŸ“· ${Z(e4.url)}`;
    if ("file" === e4.type && "audio" === e4.subtype) return `ðŸŽ§ ${Z(e4.url)}`;
    if ("file" === e4.type && "voice" === e4.subtype) {
      const t4 = e4.duration;
      if (void 0 === t4) return "ðŸŽ™ï¸";
      return `ðŸŽ™ï¸ (${Math.floor(t4 / 60)}:${Math.floor(t4 % 60).toString().padStart(2, "0")})`;
    }
    if ("file" === e4.type) return e4.subtype, `ðŸ“Ž ${Z(e4.url)}`;
    if ("location" === e4.type) return "ðŸ“";
    return "";
  }(e3, t2));
  return s2.join("\n\n");
}
function ie(e2, t2) {
  return e2.flatMap((e3) => {
    if ("string" == typeof e3) return e3;
    switch (e3.type) {
      case "blockquote":
      case "bold":
      case "italic":
      case "strikethrough":
      case "link":
      case "actionlink":
      case "actionLink":
      case "actionbutton":
      case "actionButton":
        return ie(e3.children, t2);
      case "bulletlist":
      case "bulletList":
        return "\n" + ie(e3.children, t2);
      case "bulletpoint":
      case "bulletPoint":
        return "- " + ie(e3.children, t2) + "\n";
      case "autolink":
      case "autoLink":
      case "codeblock":
      case "codeBlock":
      case "codespan":
      case "codeSpan":
      case "emoji":
      case "customemoji":
      case "customEmoji":
        return e3.text;
      case "suppressed":
        return t2.contactInfoHiddenText;
      case "mention":
        return `@${e3.text}`;
    }
  }).join("");
}
function ae(e2) {
  return _({ id: e2.id, name: e2.name, custom: _(e2.custom), locale: e2.locale, photoUrl: e2.photoUrl, role: e2.role, welcomeMessage: e2.welcomeMessage });
}
function oe(e2, t2) {
  return _({ user: t2, access: e2.access, notify: e2.notify, joinedAt: e2.joinedAt });
}
function ue(e2) {
  const t2 = Object.entries(e2).map(([e3, t3]) => _({ emoji: e3, count: t3.count, currentUserReacted: t3.currentUserReacted }));
  return t2.sort((e3, t3) => e3.emoji.localeCompare(t3.emoji)), _(t2);
}
class ce extends z {
  constructor(e2, t2, s2, n2, r2) {
    super(e2, n2, r2), this.userId = t2, this.realtimeClient = s2, this.unsubscribeDebounceMs = 1e4;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      const t2 = yield this.realtimeClient.call("GET", ["users", this.userId], { includePrivateFields: false }, { bypassCache: true });
      return t2.ok ? c({ snapshot: ae(t2.value.data), lastChanged: e2 }) : "server" === t2.where && 404 === t2.value.status ? c({ snapshot: null, lastChanged: e2 }) : t2;
    });
  }
  equal(e2, t2) {
    return W(e2.snapshot, t2.snapshot);
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      return c(t2);
    });
  }
  userCreated(e2, t2) {
    this.mutate(e2, (s2) => null !== s2.value.snapshot ? s2 : c({ snapshot: ae(t2.state), lastChanged: e2 }));
  }
  userEdited(e2, t2) {
    this.mutate(e2, (s2) => {
      const n2 = s2.value.snapshot;
      if (null === n2) return console.warn("[TalkJS] Received a 'used edited' event for a user that we thought didn't exist."), s2;
      return c({ snapshot: { id: n2.id, name: j(n2.name, t2.diff.name), custom: $(n2.custom, t2.diff.custom), locale: j(n2.locale, t2.diff.locale), photoUrl: j(n2.photoUrl, t2.diff.photoUrl), role: j(n2.role, t2.diff.role), welcomeMessage: j(n2.welcomeMessage, t2.diff.welcomeMessage) }, lastChanged: e2 });
    });
  }
  getFromCache() {
    return __async(this, null, function* () {
      const e2 = yield this.mostRecentState.resultPromise;
      return e2.ok ? null === e2.value.snapshot ? h({ status: 404, errorCode: "USER_NOT_FOUND", reasons: ["That user does not exist yet"] }) : c({ status: 200, data: { id: e2.value.snapshot.id, name: e2.value.snapshot.name, custom: e2.value.snapshot.custom, locale: e2.value.snapshot.locale, photoUrl: e2.value.snapshot.photoUrl, role: e2.value.snapshot.role, welcomeMessage: e2.value.snapshot.welcomeMessage } }) : l("NOT_IN_CACHE");
    });
  }
  teardownNested(e2) {
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      return false;
    });
  }
}
class le extends G {
  constructor(e2, t2, s2, n2) {
    super(e2, {}), this.conversationId = t2, this.message = s2, this.realtimeClient = n2;
  }
  get messageId() {
    return "string" == typeof this.message ? this.message : this.message.id;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      let t2;
      if ("object" == typeof this.message) t2 = this.message;
      else {
        const e3 = yield this.realtimeClient.call("GET", ["me", "conversations", this.conversationId, "messages", this.message], {}, { bypassCache: true });
        if (!e3.ok) return e3;
        t2 = e3.value.data;
      }
      return c({ lastChanged: e2, sender: null === t2.senderId ? null : this.realtimeClient.internalSubscribe(["users", t2.senderId]), data: { id: t2.id, type: t2.type, custom: _(t2.custom), createdAt: t2.createdAt, editedAt: t2.editedAt, referencedMessageId: t2.referencedMessageId, origin: t2.origin, plaintext: re(t2.content, {}), content: P(t2.content), reactions: ue(t2.reactions) } });
    });
  }
  refetch(e2) {
    throw "Do not call refetch on message data stores, it can return outdated data. Destroy and remake them instead";
  }
  equal(e2, t2) {
    return W(e2.data, t2.data);
  }
  teardownNested(e2) {
    var _a2;
    (_a2 = e2.sender) == null ? void 0 : _a2.unsubscribe();
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      var _a2;
      const n2 = (_a2 = s2.sender) == null ? void 0 : _a2.store;
      return true === (yield n2 == null ? void 0 : n2.changedBetween(e2, t2));
    });
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      var _a2, _b2, _c;
      const s2 = yield (_b2 = (_a2 = t2.sender) == null ? void 0 : _a2.store) == null ? void 0 : _b2.getDeep(e2);
      if (false === (s2 == null ? void 0 : s2.ok)) return s2;
      if (null === t2.data) return c({ snapshot: null });
      const n2 = s2 == null ? void 0 : s2.value;
      return c({ snapshot: _({ sender: (_c = n2 == null ? void 0 : n2.snapshot) != null ? _c : null, id: t2.data.id, type: t2.data.type, custom: _(t2.data.custom), createdAt: t2.data.createdAt, editedAt: t2.data.editedAt, origin: t2.data.origin, plaintext: t2.data.plaintext, content: t2.data.content, referencedMessageId: t2.data.referencedMessageId, reactions: t2.data.reactions }) });
    });
  }
  messageEdited(e2, t2) {
    this.mutate(e2, (s2) => {
      if (null === s2.value.data) return s2;
      const n2 = s2.value.data.content, r2 = (i2 = n2, void 0 === (a2 = t2.diff.content) ? i2 : P(a2));
      var i2, a2;
      const o2 = n2 === r2 ? s2.value.data.plaintext : re(r2, {});
      return c({ lastChanged: e2, sender: s2.value.sender, data: { id: s2.value.data.id, type: s2.value.data.type, createdAt: s2.value.data.createdAt, origin: s2.value.data.origin, referencedMessageId: s2.value.data.referencedMessageId, editedAt: j(s2.value.data.editedAt, t2.diff.editedAt), custom: $(s2.value.data.custom, t2.diff.custom), plaintext: o2, content: r2, reactions: he(s2.value.data.reactions, t2.diff.reactions) } });
    });
  }
  messageDeleted(e2, t2) {
    this.mutate(e2, (s2) => null === s2.value.data ? s2 : this.messageId === t2.messageId ? (this.teardownNested(s2.value), c({ lastChanged: e2, sender: null, data: null })) : s2.value.data.referencedMessageId === t2.messageId ? c({ lastChanged: e2, sender: s2.value.sender, data: { id: s2.value.data.id, type: s2.value.data.type, createdAt: s2.value.data.createdAt, origin: s2.value.data.origin, referencedMessageId: null, editedAt: s2.value.data.editedAt, custom: s2.value.data.custom, plaintext: s2.value.data.plaintext, content: s2.value.data.content, reactions: s2.value.data.reactions } }) : s2);
  }
  getFromCache() {
    return __async(this, null, function* () {
      var _b2;
      const e2 = yield this.mostRecentState.resultPromise;
      if (!e2.ok) return l("NOT_IN_CACHE");
      if (null === e2.value.data) {
        return h({ status: 404, errorCode: "MESSAGE_NOT_FOUND", reasons: ["No message with that ID exists"] });
      }
      const _a2 = e2.value, { sender: t2 } = _a2, s2 = __objRest(_a2, ["sender"]), n2 = {};
      return s2.data.reactions.forEach((e3) => {
        n2[e3.emoji] = { count: e3.count, currentUserReacted: e3.currentUserReacted };
      }), c({ status: 200, data: __spreadProps(__spreadValues({}, s2.data), { senderId: (_b2 = t2 == null ? void 0 : t2.store.userId) != null ? _b2 : null, reactions: n2 }) });
    });
  }
}
function he(e2, t2) {
  if (void 0 === t2) return e2;
  const s2 = e2.map((e3) => {
    const s3 = t2[e3.emoji];
    return void 0 === s3 ? e3 : _(null === s3 ? __spreadProps(__spreadValues({}, e3), { count: 0 }) : { emoji: e3.emoji, count: j(e3.count, s3.count), currentUserReacted: j(e3.currentUserReacted, s3.currentUserReacted) });
  }).filter((e3) => e3.count > 0), n2 = new Set(s2.map((e3) => e3.emoji));
  for (const e3 in t2) {
    const r2 = t2[e3];
    r2 && !n2.has(e3) && s2.push(_({ emoji: e3, count: r2.count, currentUserReacted: r2.currentUserReacted }));
  }
  return s2.sort((e3, t3) => e3.emoji.localeCompare(t3.emoji)), _(s2);
}
class de extends G {
  constructor(e2, t2, s2, n2) {
    super(e2, {}), this.createdAt = t2, this.dataStore = s2, this.referencedDataStore = n2;
  }
  get messageId() {
    return this.dataStore.messageId;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      return c({ lastChanged: e2, dataStore: this.dataStore, referencedDataStore: this.referencedDataStore });
    });
  }
  refetch(e2) {
    throw "Do not call refetch on message stores, it can return outdated data. Destroy and remake them instead";
  }
  equal(e2, t2) {
    return true;
  }
  teardownNested(e2) {
  }
  anyChildChanged(_0, _1, _2) {
    return __async(this, arguments, function* (e2, t2, { dataStore: s2, referencedDataStore: n2 }) {
      if (true === (yield s2.changedBetween(e2, t2))) return true;
      return true === (yield n2 == null ? void 0 : n2.changedBetween(e2, t2));
    });
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      var _a2, _b2, _c;
      const s2 = yield t2.dataStore.getDeep(e2);
      if (!s2.ok) return s2;
      const n2 = s2.value;
      if (null === n2.snapshot) return c({ snapshot: null });
      const r2 = yield (_a2 = t2.referencedDataStore) == null ? void 0 : _a2.getDeep(e2);
      if (r2 && !r2.ok) return r2;
      const i2 = (_b2 = r2 == null ? void 0 : r2.value) != null ? _b2 : null, a2 = (_c = i2 == null ? void 0 : i2.snapshot) != null ? _c : null;
      return c({ snapshot: _({ id: n2.snapshot.id, type: n2.snapshot.type, sender: n2.snapshot.sender, custom: _(n2.snapshot.custom), createdAt: n2.snapshot.createdAt, editedAt: n2.snapshot.editedAt, referencedMessage: a2, origin: n2.snapshot.origin, plaintext: n2.snapshot.plaintext, content: n2.snapshot.content, reactions: n2.snapshot.reactions }) });
    });
  }
}
class pe extends z {
  constructor(e2, t2, s2, n2, r2) {
    super(e2, n2, r2), this.conversationId = t2, this.realtimeClient = s2, this.handlers = r2, this.unsubscribeDebounceMs = 1e3, this.pendingLoadMore = void 0;
  }
  listen(e2) {
    return this.onlyUsedInternally && this.mostRecentState.resultPromise.then((e3) => {
      if (e3.ok && null !== e3.value.inWindow) {
        const t2 = 30 - e3.value.inWindow.length;
        t2 > 0 && this._loadMoreMessages(t2);
      }
    }), super.listen(e2);
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      const t2 = this.onlyUsedInternally ? 1 : 30, s2 = yield fe({ realtimeClient: this.realtimeClient, conversationId: this.conversationId, count: t2 });
      return s2.ok ? null === s2.value.messages ? c({ lastChanged: e2, lastMessageChanged: e2, stores: null, inWindow: null, windowEnd: null }) : me({ seq: e2, messages: s2.value.messages, cursor: s2.value.nextCursor, conversationId: this.conversationId, realtimeClient: this.realtimeClient }) : s2;
    });
  }
  teardownNested(e2) {
    if (e2.stores) {
      const t2 = l("TERMINATED");
      Object.values(e2.stores).forEach((e3) => e3.setError(t2)), e2.inWindow.forEach((e3) => e3.setError(t2));
    }
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      for (const n2 in s2.stores) {
        const r2 = s2.stores[n2];
        if (true === (yield r2 == null ? void 0 : r2.changedBetween(e2, t2))) return true;
      }
      return false;
    });
  }
  lastMessageChangedBetween(e2, t2) {
    return __async(this, null, function* () {
      if (e2 >= t2) return false;
      const s2 = yield this.get(t2).resultPromise;
      if (!s2.ok) return false;
      if (s2.value.lastMessageChanged > e2) return true;
      if (null === s2.value.stores) return false;
      const n2 = s2.value.inWindow[0];
      if (void 0 === n2) return false;
      return true === (yield n2.changedBetween(e2, t2));
    });
  }
  equal(e2, t2) {
    return null === e2.stores && null === t2.stores || null !== e2.stores && null !== t2.stores && (!!W(Object.keys(e2.stores), Object.keys(t2.stores)) && (!!W(e2.inWindow.map((e3) => e3.messageId), t2.inWindow.map((e3) => e3.messageId)) && W(e2.windowEnd, t2.windowEnd)));
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      if (null === t2.stores) return c({ snapshot: null, loadedAll: true });
      const s2 = yield Promise.all(t2.inWindow.map((t3) => t3.getDeep(e2))), n2 = s2.find((e3) => !e3.ok);
      if (n2) return n2;
      return c({ snapshot: _(s2.filter((e3) => null !== e3.value.snapshot).map((e3) => e3.value.snapshot)), loadedAll: null === t2.windowEnd });
    });
  }
  loadMore(e2) {
    return __async(this, null, function* () {
      if (this.pendingLoadMore) return this.pendingLoadMore;
      const t2 = o();
      this.pendingLoadMore = t2.promise, yield this._loadMoreMessages(e2), t2.resolve(), this.pendingLoadMore = void 0;
    });
  }
  _loadMoreMessages(e2 = 30) {
    return __async(this, null, function* () {
      const t2 = yield this.mostRecentState.resultPromise;
      if (!t2.ok) return;
      if (null === t2.value.windowEnd) return;
      const s2 = t2.value.windowEnd.cursor, n2 = yield fe({ count: e2, cursor: s2, conversationId: this.conversationId, realtimeClient: this.realtimeClient });
      yield this.handlers.onLoadedMore({ type: "virtual.messages.loadedmore", conversationId: this.conversationId, data: n2 });
    });
  }
  loadedMore(e2, t2) {
    this.mutate(e2, (s2) => null === s2.value.windowEnd ? s2 : t2.data.ok ? null === t2.data.value.messages ? (console.warn("[TalkJS] When loading more messages, the conversation no longer existed. We should have been told about this."), s2) : me({ seq: e2, prevState: s2.value, messages: t2.data.value.messages, cursor: t2.data.value.nextCursor, conversationId: this.conversationId, realtimeClient: this.realtimeClient }) : t2.data);
  }
  messageCreated(e2, t2) {
    this.mutate(e2, (s2) => {
      if (null === s2.value.stores) return console.warn("[TalkJS] Received a 'message.created' event for a nonexistent conversation."), s2;
      if (s2.value.windowEnd && t2.state.createdAt < s2.value.windowEnd.oldestMessageTs) return s2;
      if (Object.hasOwnProperty.call(s2.value.stores, t2.state.id)) return s2;
      const n2 = __spreadValues({}, s2.value.stores), r2 = new le(e2, this.conversationId, t2.state, this.realtimeClient);
      n2[t2.state.id] = r2;
      const i2 = t2.state.referencedMessageId;
      let a2;
      null === i2 ? a2 = null : i2 in n2 ? a2 = n2[i2] : (a2 = new le(e2, this.conversationId, i2, this.realtimeClient), n2[i2] = a2);
      const o2 = new de(e2, t2.state.createdAt, r2, a2), u2 = [...s2.value.inWindow, o2];
      u2.sort((e3, t3) => t3.createdAt - e3.createdAt);
      const l2 = u2[0].messageId === t2.messageId ? e2 : s2.value.lastMessageChanged;
      return c({ lastChanged: e2, lastMessageChanged: l2, stores: n2, inWindow: u2, windowEnd: s2.value.windowEnd });
    });
  }
  messageEdited(e2, t2) {
    this.mutate(e2, (s2) => {
      var _a2;
      return null === s2.value.stores ? (console.warn("[TalkJS] Received a 'message.edited' event for a nonexistent conversation."), s2) : ((_a2 = s2.value.stores[t2.messageId]) == null ? void 0 : _a2.messageEdited(e2, t2), s2);
    });
  }
  messageDeleted(e2, t2) {
    this.mutate(e2, (s2) => {
      if (null === s2.value.stores) return console.warn("[TalkJS] Received a 'message.deleted' event for a conversation that we thought didn't exist."), s2;
      if (Object.values(s2.value.stores).forEach((s3) => s3.messageDeleted(e2, t2)), void 0 === s2.value.stores[t2.messageId]) return s2;
      const n2 = __spreadValues({}, s2.value.stores);
      delete n2[t2.messageId];
      const r2 = s2.value.inWindow.filter((e3) => e3.messageId !== t2.messageId);
      if (t2.newLastMessage && 0 === r2.length) {
        const s3 = new le(e2, this.conversationId, t2.newLastMessage, this.realtimeClient);
        n2[s3.messageId] = s3;
        const i3 = t2.newLastMessage.referencedMessageId;
        let a2;
        null === i3 ? a2 = null : i3 in n2 ? a2 = n2[i3] : (a2 = new le(e2, this.conversationId, i3, this.realtimeClient), n2[i3] = a2);
        const o2 = new de(e2, t2.newLastMessage.createdAt, s3, a2);
        r2.push(o2);
      }
      const i2 = void 0 !== t2.newLastMessage ? e2 : s2.value.lastMessageChanged;
      return c({ lastChanged: e2, lastMessageChanged: i2, stores: n2, inWindow: r2, windowEnd: s2.value.windowEnd });
    });
  }
  conversationCleared(e2, t2) {
    this.mutate(e2, (t3) => {
      var _a2;
      return 0 === ((_a2 = t3.value.inWindow) == null ? void 0 : _a2.length) && null === t3.value.windowEnd ? t3 : (this.teardownNested(t3.value), c({ lastChanged: e2, lastMessageChanged: e2, stores: {}, inWindow: [], windowEnd: null }));
    });
  }
  sideCreated(e2, t2) {
    const s2 = this.fetchInitial(e2);
    this.mutate(e2, (e3) => null !== e3.value.stores ? (s2.then((e4) => {
      e4.ok && this.teardownNested(e4.value);
    }), e3) : s2);
  }
  sideDeleted(e2, t2) {
    this.mutate(e2, (t3) => null === t3.value.stores ? t3 : (this.teardownNested(t3.value), c({ lastChanged: e2, lastMessageChanged: e2, stores: null, inWindow: null, windowEnd: null })));
  }
  getMessageFromCache(e2) {
    return __async(this, null, function* () {
      const t2 = yield this.mostRecentState.resultPromise;
      if (!t2.ok) return l("NOT_IN_CACHE");
      if (null === t2.value.stores) return l("NOT_IN_CACHE");
      const s2 = t2.value.stores[e2];
      return void 0 === s2 ? l("NOT_IN_CACHE") : s2.getFromCache();
    });
  }
}
function fe(_0) {
  return __async(this, arguments, function* ({ cursor: e2, realtimeClient: t2, conversationId: s2, count: n2 }) {
    const r2 = { limit: n2, cursor: e2 }, i2 = yield t2.call("GET", ["me", "conversations", s2, "messages"], r2, { bypassCache: true });
    if (i2.ok) {
      const { data: e3, cursor: t3 } = i2.value.data;
      return c({ messages: e3, nextCursor: t3 });
    }
    return (i2.ok || "server" !== i2.where || 404 !== i2.value.status) && (i2.ok || "server" !== i2.where || 403 !== i2.value.status || "NOT_A_PARTICIPANT" !== i2.value.errorCode) ? i2 : c({ messages: null, nextCursor: null });
  });
}
function me({ seq: e2, prevState: t2, messages: s2, cursor: n2, conversationId: r2, realtimeClient: i2 }) {
  var _a2, _b2, _c, _d;
  const a2 = t2 ? __spreadValues({}, t2.stores) : {};
  for (const t3 of s2) if (void 0 === a2[t3.id]) {
    const s3 = new le(e2, r2, t3, i2);
    a2[s3.messageId] = s3;
  }
  for (const t3 of s2) {
    const s3 = t3.referencedMessageId;
    if (s3 && void 0 === a2[s3]) {
      const t4 = new le(e2, r2, s3, i2);
      a2[t4.messageId] = t4;
    }
  }
  const o2 = t2 ? [...t2.inWindow] : [];
  for (const t3 of s2) o2.push(new de(e2, t3.createdAt, a2[t3.id], t3.referencedMessageId ? a2[t3.referencedMessageId] : null));
  o2.sort((e3, t3) => t3.createdAt - e3.createdAt);
  const u2 = (_b2 = (_a2 = t2 == null ? void 0 : t2.inWindow) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.messageId, l2 = (_c = o2 == null ? void 0 : o2[0]) == null ? void 0 : _c.messageId, h2 = u2 === l2 ? (_d = t2 == null ? void 0 : t2.lastMessageChanged) != null ? _d : e2 : e2;
  if (null === n2) return c({ lastChanged: e2, lastMessageChanged: h2, stores: a2, inWindow: o2, windowEnd: null });
  return c({ lastChanged: e2, lastMessageChanged: h2, stores: a2, inWindow: o2, windowEnd: { cursor: n2, oldestMessageTs: s2[s2.length - 1].createdAt } });
}
class ge extends z {
  constructor(e2, t2, s2, n2, r2) {
    super(e2, n2, r2), this.convData = t2, this.realtimeClient = s2, this.unsubscribeDebounceMs = 0;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      return c({ lastChanged: e2, convData: this.convData });
    });
  }
  teardownNested(e2) {
    e2.convData.unsubscribe();
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      return s2.convData.store.changedBetween(e2, t2);
    });
  }
  equal(e2, t2) {
    return true;
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      return t2.convData.store.getDeep(e2);
    });
  }
  getFromCache() {
    return __async(this, null, function* () {
      return this.convData.store.getFromCache();
    });
  }
}
function ve(e2, t2) {
  for (let s2 in e2) Object.prototype.hasOwnProperty.call(e2, s2) && t2(e2[s2], s2);
}
function we(e2, t2) {
  return function(e3, t3) {
    let s2 = {}, n2 = 0;
    return ve(e3, (e4, r2) => {
      const [i2, a2] = t3([r2, e4], n2++);
      s2[i2] = a2;
    }), s2;
  }(e2, ([e3, s2]) => [e3, t2(s2, e3)]);
}
class be extends z {
  constructor(e2, t2, s2, n2, r2) {
    super(e2, n2, r2), this.conversationId = t2, this.realtimeClient = s2, this.unsubscribeDebounceMs = 1e4;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      const t2 = yield this.realtimeClient.call("GET", ["me", "conversations", this.conversationId, "typing"], {}, { bypassCache: true });
      if (!t2.ok && "server" === t2.where && 404 === t2.value.status) return c({ data: null, lastChanged: e2 });
      if (!t2.ok && "server" === t2.where && 403 === t2.value.status && "NOT_A_PARTICIPANT" === t2.value.errorCode) return c({ data: null, lastChanged: e2 });
      if (!t2.ok) return t2;
      const s2 = t2.value.data;
      if (s2.many) return c({ data: { usersTyping: null, many: true }, userSubscriptions: {}, lastChanged: e2 });
      return c({ data: s2, userSubscriptions: we(s2.usersTyping, (e3, t3) => this.realtimeClient.internalSubscribe(["users", t3])), lastChanged: e2 });
    });
  }
  equal(e2, t2) {
    return W(e2.data, t2.data);
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      if (null === t2.data) return c({ snapshot: null, lastChanged: t2.lastChanged });
      if (t2.data.many) return c({ snapshot: _({ many: true }), lastChanged: t2.lastChanged });
      const s2 = Object.entries(t2.data.usersTyping).sort(([e3, t3], [s3, n3]) => t3 - n3).map(([e3, t3]) => e3).map((s3) => t2.userSubscriptions[s3].store.getDeep(e2)), n2 = yield Promise.all(s2), r2 = n2.find((e3) => !e3.ok);
      if (r2) return r2;
      const i2 = n2.map((e3) => e3.value), a2 = i2.map((e3) => e3.snapshot), o2 = i2.map((e3) => e3.lastChanged), u2 = Math.max(t2.lastChanged, ...o2);
      return c({ snapshot: _({ users: _(a2), many: false }), lastChanged: u2 });
    });
  }
  typingAvailable(e2, t2) {
    this.mutate(e2, () => c({ data: t2.state, userSubscriptions: t2.state.many ? {} : we(t2.state.usersTyping, (e3, t3) => this.realtimeClient.internalSubscribe(["users", t3])), lastChanged: e2 }));
  }
  typingChanged(e2, t2) {
    this.mutate(e2, (s2) => {
      if (null === s2.value.data) return s2;
      if (void 0 === t2.diff.many) {
        if (true === s2.value.data.many) return s2;
        const n2 = __spreadValues({}, s2.value.data.usersTyping), r2 = __spreadValues({}, s2.value.userSubscriptions);
        return ve(t2.diff.usersTyping, (e3, t3) => {
          var _a2;
          "number" == typeof e3 ? (n2[t3] = e3, r2[t3] = this.realtimeClient.internalSubscribe(["users", t3])) : null === e3 && (delete n2[t3], (_a2 = r2[t3]) == null ? void 0 : _a2.unsubscribe(), delete r2[t3]);
        }), c({ data: { usersTyping: n2, many: false }, userSubscriptions: r2, lastChanged: e2 });
      }
      if (true === t2.diff.many) return s2.value.data.many ? s2 : c({ data: { usersTyping: null, many: true }, userSubscriptions: {}, lastChanged: e2 });
      if (false === t2.diff.many) {
        if (false === s2.value.data.many) return s2;
        const n2 = we(t2.diff.usersTyping, (e3, t3) => this.realtimeClient.internalSubscribe(["users", t3]));
        return c({ data: t2.diff, userSubscriptions: n2, lastChanged: e2 });
      }
      throw t2.diff, "Unreachable";
    });
  }
  sideDeleted(e2, t2) {
    this.mutate(e2, (t3) => null === t3.value.data ? t3 : c({ data: null, lastChanged: e2 }));
  }
  teardownNested(e2) {
    e2.data && ve(e2.userSubscriptions, (e3) => e3.unsubscribe());
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      var _a2;
      if (null === s2.data) return false;
      for (const n2 in s2.userSubscriptions) {
        const r2 = s2.userSubscriptions[n2];
        if (true === (yield (_a2 = r2 == null ? void 0 : r2.store) == null ? void 0 : _a2.changedBetween(e2, t2))) return true;
      }
      return false;
    });
  }
}
class ye extends G {
  constructor(e2, t2, s2, n2) {
    super(e2, {}), this.conversationId = t2, this.participantData = s2, this.realtimeClient = n2;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      return c({ lastChanged: e2, user: this.realtimeClient.internalSubscribe(["users", this.participantData.id]), data: this.participantData });
    });
  }
  refetch(e2) {
    throw "Do not call refetch on participant data stores, it can return outdated data. Destroy and remake them instead";
  }
  equal(e2, t2) {
    var _a2, _b2, _c, _d;
    return ((_b2 = (_a2 = e2.user) == null ? void 0 : _a2.store) == null ? void 0 : _b2.userId) === ((_d = (_c = t2.user) == null ? void 0 : _c.store) == null ? void 0 : _d.userId) && W(e2.data, t2.data);
  }
  teardownNested(e2) {
    var _a2;
    (_a2 = e2.user) == null ? void 0 : _a2.unsubscribe();
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      var _a2;
      const n2 = (_a2 = s2.user) == null ? void 0 : _a2.store;
      return true === (yield n2 == null ? void 0 : n2.changedBetween(e2, t2));
    });
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      if (null === t2.data) return c({ snapshot: null });
      const s2 = yield t2.user.store.getDeep(e2);
      if (false === s2.ok) return s2;
      const n2 = s2.value.snapshot;
      return c({ snapshot: oe(t2.data, n2) });
    });
  }
  participantEdited(e2, t2) {
    this.mutate(e2, (s2) => {
      if (null === s2.value.data) return s2;
      return c({ lastChanged: e2, user: s2.value.user, data: { id: s2.value.data.id, access: j(s2.value.data.access, t2.diff.access), notify: j(s2.value.data.notify, t2.diff.notify), joinedAt: s2.value.data.joinedAt } });
    });
  }
  participantDeleted(e2, t2) {
    this.mutate(e2, (t3) => null === t3.value.data ? t3 : (this.teardownNested(t3.value), c({ lastChanged: e2, user: null, data: null })));
  }
  getFromCache() {
    return __async(this, null, function* () {
      const e2 = yield this.mostRecentState.resultPromise;
      if (!e2.ok) return l("NOT_IN_CACHE");
      if (null === e2.value.data) {
        return h({ status: 404, errorCode: "PARTICIPANT_NOT_FOUND", reasons: ["No participant with that ID exists"] });
      }
      return c({ status: 200, data: e2.value.data });
    });
  }
}
class Ce extends z {
  constructor(e2, t2, s2, n2, r2) {
    super(e2, n2, r2), this.conversationId = t2, this.realtimeClient = s2, this.handlers = r2, this.unsubscribeDebounceMs = 1e3, this.pendingLoadMore = void 0;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      const t2 = yield Ae({ realtimeClient: this.realtimeClient, conversationId: this.conversationId, count: 10 });
      return t2.ok ? null === t2.value.participants ? c({ lastChanged: e2, stores: null, inWindow: null, windowEnd: null }) : Ee({ seq: e2, participants: t2.value.participants, cursor: t2.value.nextCursor, conversationId: this.conversationId, realtimeClient: this.realtimeClient }) : t2;
    });
  }
  teardownNested(e2) {
    if (e2.stores) {
      const t2 = l("TERMINATED");
      Object.values(e2.stores).forEach((e3) => e3.setError(t2));
    }
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      for (const n2 in s2.stores) {
        const r2 = s2.stores[n2];
        if (true === (yield r2 == null ? void 0 : r2.changedBetween(e2, t2))) return true;
      }
      return false;
    });
  }
  equal(e2, t2) {
    return null === e2.stores && null === t2.stores || null !== e2.stores && null !== t2.stores && (!!W(Object.keys(e2.stores), Object.keys(t2.stores)) && W(e2.windowEnd, t2.windowEnd));
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      if (null === t2.stores) return c({ snapshot: null, loadedAll: true });
      const s2 = yield Promise.all(Object.values(t2.stores).map((t3) => t3.getDeep(e2))), n2 = s2.find((e3) => !e3.ok);
      if (n2) return n2;
      const r2 = s2.filter((e3) => null !== e3.value.snapshot).map((e3) => e3.value.snapshot);
      return r2.sort((e3, t3) => t3.joinedAt - e3.joinedAt), c({ snapshot: _(r2), loadedAll: null === t2.windowEnd });
    });
  }
  loadMore(e2) {
    return __async(this, null, function* () {
      if (this.pendingLoadMore) return this.pendingLoadMore;
      const t2 = o();
      this.pendingLoadMore = t2.promise, yield this._loadMoreParticipants(e2), t2.resolve(), this.pendingLoadMore = void 0;
    });
  }
  _loadMoreParticipants(e2 = 10) {
    return __async(this, null, function* () {
      const t2 = yield this.mostRecentState.resultPromise;
      if (!t2.ok) return;
      if (null === t2.value.windowEnd) return;
      const s2 = t2.value.windowEnd.cursor, n2 = yield Ae({ count: e2, cursor: s2, conversationId: this.conversationId, realtimeClient: this.realtimeClient });
      yield this.handlers.onLoadedMore({ type: "virtual.participants.loadedmore", conversationId: this.conversationId, data: n2 });
    });
  }
  loadedMore(e2, t2) {
    this.mutate(e2, (s2) => null === s2.value.windowEnd ? s2 : t2.data.ok ? null === t2.data.value.participants ? (console.warn("[TalkJS] When loading more participants, the conversation no longer existed. We should have been told about this."), s2) : Ee({ seq: e2, prevStores: s2.value.stores, participants: t2.data.value.participants, cursor: t2.data.value.nextCursor, conversationId: this.conversationId, realtimeClient: this.realtimeClient }) : t2.data);
  }
  participantCreated(e2, t2) {
    this.mutate(e2, (s2) => {
      if (null === s2.value.stores) return console.warn("[TalkJS] Received a 'participant.created' event for a nonexistent conversation."), s2;
      if (s2.value.windowEnd && t2.state.joinedAt < s2.value.windowEnd.oldestParticipantTs) return s2;
      if (Object.hasOwnProperty.call(s2.value.stores, t2.state.id)) return s2;
      const n2 = __spreadValues({}, s2.value.stores), r2 = new ye(e2, this.conversationId, t2.state, this.realtimeClient);
      n2[t2.state.id] = r2;
      return c({ lastChanged: e2, stores: n2, windowEnd: s2.value.windowEnd });
    });
  }
  participantEdited(e2, t2) {
    this.mutate(e2, (s2) => {
      var _a2;
      return null === s2.value.stores ? (console.warn("[TalkJS] Received a 'participant.edited' event for a nonexistent conversation."), s2) : ((_a2 = s2.value.stores[t2.userId]) == null ? void 0 : _a2.participantEdited(e2, t2), s2);
    });
  }
  participantDeleted(e2, t2) {
    this.mutate(e2, (s2) => {
      if (null === s2.value.stores) return console.warn("[TalkJS] Received a 'participant.deleted' event for a conversation that we thought didn't exist."), s2;
      const n2 = s2.value.stores[t2.userId];
      if (void 0 === n2) return s2;
      n2.participantDeleted(e2, t2);
      const r2 = __spreadValues({}, s2.value.stores);
      return delete r2[t2.userId], c({ lastChanged: e2, stores: r2, windowEnd: s2.value.windowEnd });
    });
  }
  sideCreated(e2, t2) {
    const s2 = this.fetchInitial(e2);
    this.mutate(e2, (e3) => null !== e3.value.stores ? (s2.then((e4) => {
      e4.ok && this.teardownNested(e4.value);
    }), e3) : s2);
  }
  sideDeleted(e2, t2) {
    this.mutate(e2, (t3) => null === t3.value.stores ? t3 : (this.teardownNested(t3.value), c({ lastChanged: e2, stores: null, inWindow: null, windowEnd: null })));
  }
  getParticipantFromCache(e2) {
    return __async(this, null, function* () {
      const t2 = yield this.mostRecentState.resultPromise;
      if (!t2.ok) return l("NOT_IN_CACHE");
      if (null === t2.value.stores) return l("NOT_IN_CACHE");
      const s2 = t2.value.stores[e2];
      return void 0 === s2 ? l("NOT_IN_CACHE") : s2.getFromCache();
    });
  }
}
function Ae(_0) {
  return __async(this, arguments, function* ({ cursor: e2, realtimeClient: t2, conversationId: s2, count: n2 }) {
    const r2 = { limit: n2, cursor: e2 }, i2 = yield t2.call("GET", ["me", "conversations", s2, "participants"], r2, { bypassCache: true });
    if (i2.ok) {
      const { data: e3, cursor: t3 } = i2.value.data;
      return c({ participants: e3, nextCursor: t3 });
    }
    return (i2.ok || "server" !== i2.where || 404 !== i2.value.status) && (i2.ok || "server" !== i2.where || 403 !== i2.value.status || "NOT_A_PARTICIPANT" !== i2.value.errorCode) ? i2 : c({ participants: null, nextCursor: null });
  });
}
function Ee({ seq: e2, prevStores: t2, participants: s2, cursor: n2, conversationId: r2, realtimeClient: i2 }) {
  const a2 = t2 ? __spreadValues({}, t2) : {};
  for (const t3 of s2) if (void 0 === a2[t3.id]) {
    const s3 = new ye(e2, r2, t3, i2);
    a2[t3.id] = s3;
  }
  if (null === n2) return c({ lastChanged: e2, stores: a2, windowEnd: null });
  return c({ lastChanged: e2, stores: a2, windowEnd: { cursor: n2, oldestParticipantTs: s2[s2.length - 1].joinedAt } });
}
class ke extends z {
  constructor(e2, t2, s2, n2, r2) {
    super(e2, n2, r2), this.getConvDataStore = t2, this.realtimeClient = s2, this.handlers = r2, this.unsubscribeDebounceMs = 1e3, this.pendingLoadMore = void 0;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      const t2 = yield xe({ realtimeClient: this.realtimeClient, count: 20 });
      return t2.ok ? null === t2.value.conversations ? c({ lastChanged: e2, stores: null, windowEnd: null }) : Ie({ seq: e2, conversations: t2.value.conversations, cursor: t2.value.nextCursor, getConvDataStore: this.getConvDataStore }) : t2;
    });
  }
  teardownNested(e2) {
    null !== e2.stores && Object.values(e2.stores).forEach((e3) => e3.unsubscribe());
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      var _a2;
      for (const n2 in s2.stores) {
        const r2 = s2.stores[n2];
        if (true === (yield (_a2 = r2 == null ? void 0 : r2.store) == null ? void 0 : _a2.changedBetween(e2, t2))) return true;
      }
      return false;
    });
  }
  equal(e2, t2) {
    return null === e2.stores && null === t2.stores || null !== e2.stores && null !== t2.stores && (!!W(Object.keys(e2.stores), Object.keys(t2.stores)) && W(e2.windowEnd, t2.windowEnd));
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      if (null === t2.stores) return c({ snapshot: _([]), loadedAll: true });
      const s2 = yield Promise.all(Object.values(t2.stores).map((t3) => t3.store.getDeep(e2))), n2 = s2.find((e3) => !e3.ok);
      if (n2) return n2;
      const r2 = s2.filter((e3) => null !== e3.value.snapshot).map((e3) => e3.value.snapshot);
      return r2.sort((e3, t3) => {
        var _a2, _b2, _c, _d;
        const s3 = (_b2 = (_a2 = e3.lastMessage) == null ? void 0 : _a2.createdAt) != null ? _b2 : e3.joinedAt;
        return ((_d = (_c = t3.lastMessage) == null ? void 0 : _c.createdAt) != null ? _d : t3.joinedAt) - s3;
      }), c({ snapshot: _(r2), loadedAll: null === t2.windowEnd });
    });
  }
  loadMore(e2) {
    return __async(this, null, function* () {
      if (this.pendingLoadMore) return this.pendingLoadMore;
      const t2 = o();
      this.pendingLoadMore = t2.promise, yield this._loadMoreConversations(e2), t2.resolve(), this.pendingLoadMore = void 0;
    });
  }
  _loadMoreConversations(e2 = 20) {
    return __async(this, null, function* () {
      const t2 = yield this.mostRecentState.resultPromise;
      if (!t2.ok) return;
      if (null === t2.value.windowEnd) return;
      const s2 = t2.value.windowEnd.cursor, n2 = yield xe({ count: e2, cursor: s2, realtimeClient: this.realtimeClient });
      yield this.handlers.onLoadedMore({ type: "virtual.conversations.loadedmore", data: n2 });
    });
  }
  getConvFromCache(e2) {
    return __async(this, null, function* () {
      const t2 = yield this.mostRecentState.resultPromise;
      if (!t2.ok) return l("NOT_IN_CACHE");
      if (null === t2.value.stores) return h({ status: 404, errorCode: "USER_NOT_FOUND", reasons: ["No user with that ID exists"] });
      const s2 = t2.value.stores[e2];
      return void 0 === s2 ? l("NOT_IN_CACHE") : s2.store.getFromCache();
    });
  }
  loadedMore(e2, t2) {
    this.mutate(e2, (s2) => null === s2.value.windowEnd ? s2 : t2.data.ok ? null === t2.data.value.conversations ? (console.warn("[TalkJS] When loading more conversations, the user stopped existing, which should be impossible."), s2) : Ie({ seq: e2, prevStores: s2.value.stores, conversations: t2.data.value.conversations, cursor: t2.data.value.nextCursor, getConvDataStore: this.getConvDataStore }) : t2.data);
  }
  userCreated(e2, t2) {
    this.mutate(e2, (e3) => null !== e3.value.stores ? e3 : c({ lastChanged: e3.value.lastChanged, stores: {}, windowEnd: null }));
  }
  sideCreated(e2, t2) {
    const s2 = this.getConvDataStore(t2.state);
    this.mutate(e2, (n2) => {
      let r2 = n2.value.stores;
      return null === r2 && (console.warn("[TalkJS] Received a 'side.created' event when we thought your user didn't exist."), r2 = {}), Object.hasOwnProperty.call(r2, t2.conversationId) ? (s2.unsubscribe(), n2) : c({ lastChanged: e2, stores: __spreadProps(__spreadValues({}, r2), { [t2.conversationId]: s2 }), windowEnd: n2.value.windowEnd });
    });
  }
  sideDeleted(e2, t2) {
    this.mutate(e2, (s2) => {
      var _a2;
      if (!Object.hasOwnProperty.call(s2.value.stores, t2.conversationId)) return s2;
      const n2 = __spreadValues({}, s2.value.stores);
      return (_a2 = n2[t2.conversationId]) == null ? void 0 : _a2.unsubscribe(), delete n2[t2.conversationId], c({ lastChanged: e2, stores: n2, windowEnd: s2.value.windowEnd });
    });
  }
  sideEdited(e2, t2) {
    const s2 = t2.diff.lastMessageAt;
    void 0 !== s2 && this.mutate(e2, (n2) => {
      var _a2;
      if (null === n2.value.stores) return console.warn("[TalkJS] Received a 'side.edited' event when we thought your user didn't exist."), n2;
      if (null === n2.value.windowEnd) return n2;
      const r2 = Object.hasOwnProperty.call(n2.value.stores, t2.conversationId);
      if (r2 && s2 < n2.value.windowEnd.oldestMessageTs) {
        const s3 = __spreadValues({}, n2.value.stores);
        return (_a2 = s3[t2.conversationId]) == null ? void 0 : _a2.unsubscribe(), delete s3[t2.conversationId], c({ lastChanged: e2, stores: s3, windowEnd: n2.value.windowEnd });
      }
      if (!r2 && s2 >= n2.value.windowEnd.oldestMessageTs) {
        const s3 = this.getConvDataStore(t2.conversationId);
        return c({ lastChanged: e2, stores: __spreadProps(__spreadValues({}, n2.value.stores), { [t2.conversationId]: s3 }), windowEnd: n2.value.windowEnd });
      }
      return n2;
    });
  }
}
function xe(_0) {
  return __async(this, arguments, function* ({ cursor: e2, realtimeClient: t2, count: s2 }) {
    const n2 = { limit: s2, cursor: e2 }, r2 = yield t2.call("GET", ["me", "conversations"], n2, { bypassCache: true });
    if (r2.ok) {
      const { data: e3, cursor: t3 } = r2.value.data;
      return c({ conversations: e3, nextCursor: t3 });
    }
    return r2.ok || "server" !== r2.where || 404 !== r2.value.status || "USER_NOT_FOUND" !== r2.value.errorCode ? r2 : c({ conversations: null, nextCursor: null });
  });
}
function Ie({ seq: e2, prevStores: t2, conversations: s2, cursor: n2, getConvDataStore: r2 }) {
  const i2 = t2 ? __spreadValues({}, t2) : {};
  for (const e3 of s2) void 0 === i2[e3.id] && (i2[e3.id] = r2(e3));
  if (null === n2) return c({ lastChanged: e2, stores: i2, windowEnd: null });
  return c({ lastChanged: e2, stores: i2, windowEnd: { cursor: n2, oldestMessageTs: Math.min(...s2.map((e3) => e3.lastMessageAt)) } });
}
class Te extends z {
  constructor(e2, t2, s2, n2, r2) {
    super(e2, n2, r2), this.conversation = t2, this.realtimeClient = s2, this.unsubscribeDebounceMs = 5e3;
  }
  get conversationId() {
    return "string" == typeof this.conversation ? this.conversation : this.conversation.id;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      const t2 = this.realtimeClient.internalSubscribe(["me", "conversations", this.conversationId, "messages"]);
      if ("object" == typeof this.conversation) return c({ lastChanged: e2, snapshot: this.conversation, messageWindow: t2 });
      const s2 = yield this.realtimeClient.call("GET", ["me", "conversations", this.conversationId], {}, { bypassCache: true });
      let n2;
      if (s2.ok) n2 = s2.value.data;
      else if ("server" === s2.where && 404 === s2.value.status) n2 = null;
      else {
        if ("server" !== s2.where || 403 !== s2.value.status || "NOT_A_PARTICIPANT" !== s2.value.errorCode) return t2.unsubscribe(), s2;
        n2 = null;
      }
      return c({ lastChanged: e2, snapshot: n2, messageWindow: t2 });
    });
  }
  teardownNested(e2) {
    var _a2;
    (_a2 = e2.messageWindow) == null ? void 0 : _a2.unsubscribe();
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      return true === (yield s2.messageWindow.store.lastMessageChangedBetween(e2, t2));
    });
  }
  equal(e2, t2) {
    return W(e2.snapshot, t2.snapshot);
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      var _a2;
      if (!t2.snapshot) return c({ snapshot: null, loadedAll: true });
      const s2 = yield t2.messageWindow.store.getDeep(e2);
      if (!s2.ok) return s2;
      const n2 = s2.value.snapshot, r2 = (_a2 = n2 == null ? void 0 : n2[0]) != null ? _a2 : null;
      return c({ snapshot: _(__spreadProps(__spreadValues({}, t2.snapshot), { custom: _(t2.snapshot.custom), welcomeMessages: _(t2.snapshot.welcomeMessages), lastMessage: r2 })) });
    });
  }
  participantEdited(e2, t2) {
    this.mutate(e2, (s2) => null === s2.value.snapshot ? (console.warn("[TalkJS] Received a 'participant.edited' event for a conversation that we thought didn't exist."), s2) : c({ lastChanged: e2, snapshot: De(s2.value.snapshot, t2.diff), messageWindow: s2.value.messageWindow }));
  }
  conversationEdited(e2, t2) {
    this.mutate(e2, (s2) => null === s2.value.snapshot ? (console.warn("[TalkJS] Received a 'conversation.edited' event for a conversation that we thought didn't exist."), s2) : c({ lastChanged: e2, snapshot: De(s2.value.snapshot, t2.diff), messageWindow: s2.value.messageWindow }));
  }
  sideEdited(e2, t2) {
    this.mutate(e2, (s2) => null === s2.value.snapshot ? (console.warn("[TalkJS] Received a 'side.edited' event for a conversation that we thought didn't exist."), s2) : c({ lastChanged: e2, snapshot: De(s2.value.snapshot, t2.diff), messageWindow: s2.value.messageWindow }));
  }
  sideCreated(e2, t2) {
    this.mutate(e2, (s2) => s2.value.snapshot ? s2 : c({ lastChanged: e2, snapshot: t2.state, messageWindow: s2.value.messageWindow }));
  }
  sideDeleted(e2, t2) {
    this.mutate(e2, (t3) => null === t3.value.snapshot ? t3 : c({ lastChanged: e2, snapshot: null, messageWindow: t3.value.messageWindow }));
  }
  getFromCache() {
    return __async(this, null, function* () {
      const e2 = yield this.mostRecentState.resultPromise;
      return e2.ok && e2.value.snapshot ? c({ status: 200, data: e2.value.snapshot }) : l("NOT_IN_CACHE");
    });
  }
}
function De(e2, t2) {
  const s2 = t2;
  return { id: e2.id, createdAt: e2.createdAt, subject: j(e2.subject, s2.subject), photoUrl: j(e2.photoUrl, s2.photoUrl), welcomeMessages: U(e2.welcomeMessages, s2.welcomeMessages), custom: $(e2.custom, s2.custom), lastMessageAt: j(e2.lastMessageAt, s2.lastMessageAt), unreadMessageCount: j(e2.unreadMessageCount, s2.unreadMessageCount), isUnread: j(e2.isUnread, s2.isUnread), access: j(e2.access, s2.access), notify: j(e2.notify, s2.notify), readUntil: j(e2.readUntil, s2.readUntil), everyoneReadUntil: j(e2.everyoneReadUntil, s2.everyoneReadUntil), joinedAt: e2.joinedAt };
}
class Se extends z {
  constructor(e2, t2, s2, n2, r2) {
    super(e2, n2, r2), this.userId = t2, this.realtimeClient = s2, this.unsubscribeDebounceMs = 1e3;
  }
  fetchInitial(e2) {
    return __async(this, null, function* () {
      const t2 = this.realtimeClient.internalSubscribe(["users", this.userId]), s2 = yield this.realtimeClient.call("GET", ["users", this.userId, "online"], {}, { bypassCache: true });
      return s2.ok || "server" !== s2.where || 404 !== s2.value.status || "USER_NOT_FOUND" !== s2.value.errorCode ? s2.ok ? c({ lastChanged: e2, user: t2, data: s2.value.data }) : s2 : c({ lastChanged: e2, user: t2, data: null });
    });
  }
  equal(e2, t2) {
    return W(e2.data, t2.data);
  }
  teardownNested(e2) {
    e2.user.unsubscribe();
  }
  anyChildChanged(e2, t2, s2) {
    return __async(this, null, function* () {
      return s2.user.store.changedBetween(e2, t2);
    });
  }
  loadNested(e2, t2) {
    return __async(this, null, function* () {
      const s2 = yield t2.user.store.getDeep(e2);
      if (!s2.ok) return s2;
      const n2 = s2.value.snapshot;
      return null === t2.data || null === n2 ? c({ snapshot: null }) : c({ snapshot: _(__spreadProps(__spreadValues({}, t2.data), { user: n2 })) });
    });
  }
  userCreated(e2, t2) {
    const s2 = this.fetchInitial(e2);
    this.mutate(e2, (e3) => null !== e3.value.data ? (s2.then((e4) => {
      e4.ok && this.teardownNested(e4.value);
    }), e3) : s2);
  }
  userOnlineChanged(e2, t2) {
    this.mutate(e2, (s2) => null === s2.value.data ? s2 : c({ lastChanged: e2, user: s2.value.user, data: t2.diff }));
  }
  getFromCache() {
    return __async(this, null, function* () {
      const e2 = yield this.mostRecentState.resultPromise;
      if (!e2.ok) return l("NOT_IN_CACHE");
      if (null === e2.value.data) {
        return h({ status: 404, errorCode: "USER_NOT_FOUND", reasons: ["No user with that ID exists"] });
      }
      const _a2 = e2.value, { user: t2 } = _a2, s2 = __objRest(_a2, ["user"]);
      return c({ status: 200, data: __spreadValues({}, s2.data) });
    });
  }
}
class Me {
  constructor(e2, t2, s2) {
    this.realtimeClient = s2, this.convDataStores = {}, this.storeMap = {}, this.emitMutex = new q(), this.virtualSeqOffset = 0, this.realPublishSeq = 0, this.refetchOnNextNetworkLoss = true, this.connection = new N(e2, t2, { onUpstreamRestarting: () => {
      this.refetchOnNextNetworkLoss = false;
    }, onReady: () => {
      this.refetchOnNextNetworkLoss = true;
    }, onResubscribeSent: () => {
      if (this.virtualSeqOffset += this.realPublishSeq, this.realPublishSeq = 0, this.refetchOnNextNetworkLoss) {
        this.virtualSeqOffset++;
        const e3 = this.virtualSeq;
        this.refetchAll(e3), this.emitAll(e3);
      }
    }, onResubscribeError: (e3, t3) => {
      var _a2;
      (_a2 = this.storeMap[Fe(e3)]) == null ? void 0 : _a2.setError(t3);
    }, onPublish: (e3, t3) => {
      this.realPublishSeq = e3;
      const s3 = this.virtualSeq;
      for (const e4 of t3) this.handlePublish(s3, e4);
      this.emitAll(s3);
    } });
  }
  get virtualSeq() {
    return this.realPublishSeq + this.virtualSeqOffset;
  }
  refetchAll(e2) {
    Object.values(this.storeMap).forEach((t2) => t2 == null ? void 0 : t2.refetch(e2));
  }
  emitAll(e2) {
    return this.emitMutex.runExclusive(() => __async(this, null, function* () {
      const t2 = Object.values(this.storeMap).map((t3) => t3 == null ? void 0 : t3.emit(e2));
      yield Promise.all(t2);
    }));
  }
  handlePublish(e2, t2) {
    var _a2, _b2, _c, _d, _e3, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s2, _t3, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D;
    switch (t2.type) {
      case "user.created":
        return (_a2 = this.storeMap[`/users/${t2.userId}`]) == null ? void 0 : _a2.userCreated(e2, t2), (_b2 = this.storeMap["/me/conversations"]) == null ? void 0 : _b2.userCreated(e2, t2), void ((_c = this.storeMap[`/users/${t2.userId}/online`]) == null ? void 0 : _c.userCreated(e2, t2));
      case "user.edited":
        return void ((_d = this.storeMap[`/users/${t2.userId}`]) == null ? void 0 : _d.userEdited(e2, t2));
      case "side.created":
        return (_e3 = this.convDataStores[t2.conversationId]) == null ? void 0 : _e3.sideCreated(e2, t2), (_f = this.storeMap[`/me/conversations/${t2.conversationId}/messages`]) == null ? void 0 : _f.sideCreated(e2, t2), (_g = this.storeMap[`/me/conversations/${t2.conversationId}/participants`]) == null ? void 0 : _g.sideCreated(e2, t2), void ((_h = this.storeMap["/me/conversations"]) == null ? void 0 : _h.sideCreated(e2, t2));
      case "side.edited":
        return (_i = this.convDataStores[t2.conversationId]) == null ? void 0 : _i.sideEdited(e2, t2), void ((_j = this.storeMap["/me/conversations"]) == null ? void 0 : _j.sideEdited(e2, t2));
      case "side.deleted":
        return (_k = this.convDataStores[t2.conversationId]) == null ? void 0 : _k.sideDeleted(e2, t2), (_l = this.storeMap[`/me/conversations/${t2.conversationId}/messages`]) == null ? void 0 : _l.sideDeleted(e2, t2), (_m = this.storeMap[`/me/conversations/${t2.conversationId}/participants`]) == null ? void 0 : _m.sideDeleted(e2, t2), (_n = this.storeMap[`/me/conversations/${t2.conversationId}/typing`]) == null ? void 0 : _n.sideDeleted(e2, t2), void ((_o = this.storeMap["/me/conversations"]) == null ? void 0 : _o.sideDeleted(e2, t2));
      case "conversation.edited":
        return void ((_p = this.convDataStores[t2.conversationId]) == null ? void 0 : _p.conversationEdited(e2, t2));
      case "message.created":
        return void ((_q = this.storeMap[`/me/conversations/${t2.conversationId}/messages`]) == null ? void 0 : _q.messageCreated(e2, t2));
      case "message.edited":
        return void ((_r = this.storeMap[`/me/conversations/${t2.conversationId}/messages`]) == null ? void 0 : _r.messageEdited(e2, t2));
      case "message.deleted":
        return void ((_s2 = this.storeMap[`/me/conversations/${t2.conversationId}/messages`]) == null ? void 0 : _s2.messageDeleted(e2, t2));
      case "typing.available":
        return void ((_t3 = this.storeMap[`/me/conversations/${t2.conversationId}/typing`]) == null ? void 0 : _t3.typingAvailable(e2, t2));
      case "typing.changed":
        return void ((_u = this.storeMap[`/me/conversations/${t2.conversationId}/typing`]) == null ? void 0 : _u.typingChanged(e2, t2));
      case "conversation.cleared":
        return void ((_v = this.storeMap[`/me/conversations/${t2.conversationId}/messages`]) == null ? void 0 : _v.conversationCleared(e2, t2));
      case "participant.edited":
        return (_w = this.convDataStores[t2.conversationId]) == null ? void 0 : _w.participantEdited(e2, t2), void ((_x = this.storeMap[`/me/conversations/${t2.conversationId}/participants`]) == null ? void 0 : _x.participantEdited(e2, t2));
      case "participant.created":
        return void ((_y = this.storeMap[`/me/conversations/${t2.conversationId}/participants`]) == null ? void 0 : _y.participantCreated(e2, t2));
      case "participant.deleted":
        return void ((_z = this.storeMap[`/me/conversations/${t2.conversationId}/participants`]) == null ? void 0 : _z.participantDeleted(e2, t2));
      case "user.online.changed":
        return void ((_A = this.storeMap[`/users/${t2.userId}/online`]) == null ? void 0 : _A.userOnlineChanged(e2, t2));
      case "virtual.conversations.loadedmore":
        return void ((_B = this.storeMap["/me/conversations"]) == null ? void 0 : _B.loadedMore(e2, t2));
      case "virtual.messages.loadedmore":
        return void ((_C = this.storeMap[`/me/conversations/${t2.conversationId}/messages`]) == null ? void 0 : _C.loadedMore(e2, t2));
      case "virtual.participants.loadedmore":
        return void ((_D = this.storeMap[`/me/conversations/${t2.conversationId}/participants`]) == null ? void 0 : _D.loadedMore(e2, t2));
    }
  }
  call(e2, t2, n2, r2) {
    return __async(this, null, function* () {
      if (!r2.bypassCache && "GET" === e2) {
        const e3 = Fe(t2);
        if (e3 in this.storeMap) {
          const t3 = e3, s2 = this.storeMap[t3];
          if (s2 && "getFromCache" in s2) {
            const e4 = yield s2.getFromCache();
            if ("NOT_IN_CACHE" !== e4.value) return e4;
          }
        } else if (s(t2, ["me", "conversations", "*", "messages", "*"])) {
          const e4 = this.storeMap[`/me/conversations/${t2[2]}/messages`];
          if (e4) {
            const s2 = yield e4.getMessageFromCache(t2[4]);
            if ("NOT_IN_CACHE" !== s2.value) return s2;
          }
        } else if (s(t2, ["me", "conversations", "*", "participants", "*"])) {
          const e4 = this.storeMap[`/me/conversations/${t2[2]}/participants`];
          if (e4) {
            const s2 = yield e4.getParticipantFromCache(t2[4]);
            if ("NOT_IN_CACHE" !== s2.value) return s2;
          }
        } else if (s(t2, ["me", "conversations", "*"])) {
          const e4 = this.storeMap["/me/conversations"];
          if (e4) {
            const s2 = yield e4.getConvFromCache(t2[2]);
            if ("NOT_IN_CACHE" !== s2.value) return s2;
          }
        }
      }
      return this.connection.call(e2, t2, n2);
    });
  }
  subscribe(e2, s2) {
    const n2 = this.getOrCreateStore(e2), r2 = o(), i2 = o();
    r2.promise.catch(() => {
    }), i2.promise.catch(() => {
    });
    const a2 = { state: { type: "pending", latestSnapshot: void 0 }, connected: r2.promise, terminated: i2.promise, loadMore: (e3) => __async(this, null, function* () {
      "loadMore" in n2 && (yield n2.loadMore(e3));
    }), unsubscribe: () => {
    } }, u2 = n2.listen((n3) => {
      if (n3.ok) {
        const e3 = !("loadedAll" in n3.value) || n3.value.loadedAll, t2 = { type: "active", latestSnapshot: n3.value.snapshot, loadedAll: e3 };
        a2.state = t2, s2 == null ? void 0 : s2(n3.value.snapshot, e3), r2.resolve(t2);
      } else if ("pending" === a2.state.type || "active" === a2.state.type) {
        if ("server" === n3.where) {
          const s3 = { type: "error", error: new Error(t(`Subscribe to ${e2.join("/")}`, n3.value)) };
          return a2.state = s3, i2.resolve(s3), void r2.reject("Subscription encountered an error during initial connection");
        }
        if ("SESSION_DESTROYED" === n3.value) {
          const e3 = { type: "error", error: new Error("Session was destroyed causing all subscriptions to be terminated") };
          return a2.state = e3, i2.resolve(e3), void r2.reject("Subscription encountered an error during initial connection");
        }
        if ("UNSUBSCRIBED" === n3.value) return;
        if ("TERMINATED" === n3.value) return;
        n3.value;
      }
    });
    return a2.unsubscribe = () => {
      if ("pending" === a2.state.type || "active" === a2.state.type) {
        u2();
        const e3 = { type: "unsubscribed" };
        a2.state = e3, i2.resolve(e3), r2.reject("Subscription was unsubscribed before connecting");
      }
    }, a2;
  }
  onVirtualPublish(e2) {
    return __async(this, null, function* () {
      this.virtualSeqOffset++;
      const t2 = this.virtualSeq;
      this.handlePublish(t2, e2), yield this.emitAll(t2);
    });
  }
  getOrCreateStore(e2) {
    const t2 = Fe(e2);
    if (t2 in this.storeMap) return this.storeMap[t2];
    this.connection.subscribe(e2).then((e3) => {
      e3.ok || s2.setError(e3);
    });
    const s2 = this.instantiateStore(e2, () => {
      delete this.storeMap[t2], this.connection.unsubscribe(e2);
    });
    return this.storeMap[t2] = s2, s2;
  }
  destroy() {
    this.storeMap = {}, this.convDataStores = {}, this.connection.destroy();
  }
  isConnected() {
    return this.connection.isConnected();
  }
  instantiateStore(e2, t2) {
    if (s(e2, ["users", "*"])) return new ce(this.virtualSeq, e2[1], this.realtimeClient, this.emitMutex, { onTeardown: t2 });
    if (s(e2, ["me", "conversations", "*"])) return new ge(this.virtualSeq, this.subscribeConvData(e2[2]), this.realtimeClient, this.emitMutex, { onTeardown: t2 });
    if (s(e2, ["me", "conversations", "*", "messages"])) return new pe(this.virtualSeq, e2[2], this.realtimeClient, this.emitMutex, { onTeardown: t2, onLoadedMore: (e3) => this.onVirtualPublish(e3) });
    if (s(e2, ["me", "conversations", "*", "participants"])) return new Ce(this.virtualSeq, e2[2], this.realtimeClient, this.emitMutex, { onTeardown: t2, onLoadedMore: (e3) => this.onVirtualPublish(e3) });
    if (s(e2, ["me", "conversations", "*", "typing"])) return new be(this.virtualSeq, e2[2], this.realtimeClient, this.emitMutex, { onTeardown: t2 });
    if (s(e2, ["me", "conversations"])) return new ke(this.virtualSeq, (e3) => this.subscribeConvData(e3), this.realtimeClient, this.emitMutex, { onTeardown: t2, onLoadedMore: (e3) => this.onVirtualPublish(e3) });
    if (s(e2, ["users", "*", "online"])) return new Se(this.virtualSeq, e2[1], this.realtimeClient, this.emitMutex, { onTeardown: t2 });
    throw "Unreachable";
  }
  subscribeConvData(e2) {
    const t2 = "string" == typeof e2 ? e2 : e2.id;
    if (Object.hasOwnProperty.call(this.convDataStores, t2)) {
      const e3 = this.convDataStores[t2];
      return { store: e3, unsubscribe: e3.registerInternalSubscription() };
    }
    const s2 = new Te(this.virtualSeq, e2, this.realtimeClient, this.emitMutex, { onTeardown: () => {
      delete this.convDataStores[t2];
    } });
    return this.convDataStores[t2] = s2, { store: s2, unsubscribe: s2.registerInternalSubscription() };
  }
}
function Fe(e2) {
  return `/${e2.join("/")}`;
}
class Be {
  constructor(e2, t2, s2) {
    this.userId = t2, this.alive = true, this.connection = new Me(e2, s2, this), s2.onTokenRefreshFailed(() => {
      this.destroy();
    });
  }
  call(_0, _1, _2) {
    return __async(this, arguments, function* (e2, t2, s2, n2 = {}) {
      return this.alive ? this.connection.call(e2, t2, s2, n2) : l("SESSION_DESTROYED");
    });
  }
  subscribe(e2, t2) {
    return this.connection.subscribe(e2, t2);
  }
  internalSubscribe(e2) {
    const t2 = this.connection.getOrCreateStore(e2);
    return { store: t2, unsubscribe: t2.registerInternalSubscription() };
  }
  destroy() {
    this.alive = false, this.connection.destroy();
  }
  isConnected() {
    return this.connection.isConnected();
  }
  listMessages(e2, t2) {
    return __async(this, null, function* () {
      const s2 = yield this.call("GET", ["me", "conversations", e2, "messages"], t2);
      if (!s2.ok) return Re(s2, "Listing messages in " + e2);
      const n2 = s2.value.data.data, r2 = yield Promise.all(n2.map((t3) => this.hydrateMessageData(t3, e2))), i2 = r2.find((e3) => !e3.ok);
      if (void 0 !== i2 && !i2.ok) return i2;
      return c(r2.map(({ value: e3 }) => e3));
    });
  }
  hydrateMessageData(e2, t2) {
    return __async(this, null, function* () {
      const s2 = null === e2.senderId ? Promise.resolve(c(null)) : this.getUser(e2.senderId), n2 = null === e2.referencedMessageId ? Promise.resolve(c(null)) : this.getReferencedMessage(t2, e2.referencedMessageId), r2 = yield s2;
      if (!r2.ok) return r2;
      const i2 = yield n2;
      if (!i2.ok) return i2;
      const a2 = function(e3, t3, s3) {
        return _({ id: e3.id, type: e3.type, sender: t3, referencedMessage: s3, custom: _(e3.custom), createdAt: e3.createdAt, editedAt: e3.editedAt, origin: e3.origin, content: e3.content, reactions: ue(e3.reactions), plaintext: re(e3.content, {}) });
      }(e2, r2.value, i2.value);
      return c(a2);
    });
  }
  getReferencedMessage(e2, t2) {
    return __async(this, null, function* () {
      const s2 = yield this.call("GET", ["me", "conversations", e2, "messages", t2], {});
      if (!s2.ok && "server" === s2.where && 404 === s2.value.status) return c(null);
      if (!s2.ok && "server" === s2.where && 403 === s2.value.status && "NOT_A_PARTICIPANT" === s2.value.errorCode) return c(null);
      if (!s2.ok) return Re(s2, `Fetching referenced message ${t2} in conversation ${e2}`);
      const n2 = s2.value.data, r2 = yield this.getUser(n2.senderId);
      if (!r2.ok) return r2;
      const i2 = function(e3, t3) {
        return _({ id: e3.id, type: e3.type, sender: t3, referencedMessageId: e3.referencedMessageId, custom: _(e3.custom), createdAt: e3.createdAt, editedAt: e3.editedAt, origin: e3.origin, content: e3.content, reactions: ue(e3.reactions), plaintext: re(e3.content, {}) });
      }(n2, r2.value);
      return c(i2);
    });
  }
  getUser(e2) {
    return __async(this, null, function* () {
      const t2 = yield this.call("GET", ["users", e2], { includePrivateFields: false });
      if (!t2.ok && "server" === t2.where && 404 === t2.value.status) return c(null);
      if (!t2.ok) return Re(t2, "Get user " + e2);
      return c(ae(t2.value.data));
    });
  }
}
function Re(e2, t2) {
  return "server" === e2.where ? h(__spreadProps(__spreadValues({}, e2.value), { operation: t2 })) : e2;
}
function Ne(e2, s2) {
  var _a2;
  if (s2.ok) return s2.value;
  throw "SESSION_DESTROYED" === s2.value ? new Error(`${e2} failed because the session was destroyed`) : new Error(t((_a2 = s2.value.operation) != null ? _a2 : e2, s2.value));
}
class _e {
  constructor(e2, t2) {
    this.id = e2, this._realtimeClient = t2;
  }
  get brandedId() {
    return this.id;
  }
  get() {
    return __async(this, null, function* () {
      const e2 = yield this._realtimeClient.getUser(this.brandedId);
      return Ne("Get user " + this.id, e2);
    });
  }
  set(t2) {
    return __async(this, null, function* () {
      null === t2.role && (t2.role = "default");
      const s2 = "string" == typeof t2.email ? [t2.email] : t2.email, n2 = "string" == typeof t2.phone ? [t2.phone] : t2.phone, r2 = yield this._realtimeClient.call("PUT", ["users", this.brandedId], __spreadProps(__spreadValues({}, t2), { email: s2, phone: n2 }));
      e("Set user " + this.id, r2);
    });
  }
  createIfNotExists(t2) {
    return __async(this, null, function* () {
      void 0 === t2.role && (t2.role = "default");
      const s2 = "string" == typeof t2.email ? [t2.email] : t2.email, n2 = "string" == typeof t2.phone ? [t2.phone] : t2.phone, r2 = yield this._realtimeClient.call("POST", ["users", this.brandedId], __spreadProps(__spreadValues({}, t2), { email: s2, phone: n2 }));
      (r2.ok || "server" !== r2.where || 409 != r2.value.status) && e(`Create user ${this.id} if not exists`, r2);
    });
  }
  subscribe(e2) {
    return this._realtimeClient.subscribe(["users", this.brandedId], e2);
  }
  subscribeOnline(e2) {
    return this._realtimeClient.subscribe(["users", this.brandedId, "online"], e2);
  }
}
class Pe {
  constructor(e2, t2, s2) {
    this.userId = e2, this.conversationId = t2, this._realtimeClient = s2;
  }
  get brandedUserId() {
    return this.userId;
  }
  get brandedConversationId() {
    return this.conversationId;
  }
  get() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("GET", ["me", "conversations", this.brandedConversationId, "participants", this.brandedUserId], {}), s2 = yield this._realtimeClient.call("GET", ["users", this.brandedUserId], { includePrivateFields: false }), [n2, r2] = yield Promise.all([t2, s2]);
      if (!n2.ok && "server" === n2.where && 404 === n2.value.status) return null;
      if (!r2.ok && "server" === r2.where && 404 === r2.value.status) return null;
      return oe(e(`Get participant ${this.userId} in conversation ${this.conversationId}`, n2), ae(e(`Get user ${this.userId}`, r2)));
    });
  }
  set() {
    return __async(this, arguments, function* (t2 = {}) {
      const s2 = yield this._realtimeClient.call("PUT", ["conversations", this.brandedConversationId, "participants", this.brandedUserId], t2);
      e(`Set participant ${this.userId} in conversation ${this.conversationId}`, s2);
    });
  }
  edit() {
    return __async(this, arguments, function* (t2 = {}) {
      const s2 = yield this._realtimeClient.call("PATCH", ["conversations", this.brandedConversationId, "participants", this.brandedUserId], t2);
      e(`Edit participant ${this.userId} in conversation ${this.conversationId}`, s2);
    });
  }
  createIfNotExists() {
    return __async(this, arguments, function* (t2 = {}) {
      const s2 = yield this._realtimeClient.call("POST", ["conversations", this.brandedConversationId, "participants", this.brandedUserId], t2);
      (s2.ok || "server" !== s2.where || 409 !== s2.value.status) && e(`Add participant ${this.userId} to conversation ${this.conversationId}`, s2);
    });
  }
  delete() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("DELETE", ["conversations", this.brandedConversationId, "participants", this.brandedUserId], {});
      (t2.ok || "server" !== t2.where || 404 !== t2.value.status) && e(`Remove participant ${this.userId} from conversation ${this.conversationId}`, t2);
    });
  }
}
function Oe(e2) {
  const t2 = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
  let s2 = 0;
  const n2 = [], r2 = e2 === s2;
  s2 = e2;
  const i2 = new Array(8);
  for (let s3 = 7; s3 >= 0; s3--) i2[s3] = t2.charAt(e2 % 64), e2 = Math.floor(e2 / 64);
  if (0 !== e2) throw new Error("We should have converted the entire timestamp.");
  let a2 = i2.join("");
  if (r2) {
    let e3;
    for (e3 = 11; e3 >= 0 && 63 === n2[e3]; e3--) n2[e3] = 0;
    n2[e3]++;
  } else for (let e3 = 0; e3 < 12; e3++) n2[e3] = Math.floor(64 * Math.random());
  for (let e3 = 0; e3 < 12; e3++) a2 += t2.charAt(n2[e3]);
  if (20 != a2.length) throw new Error("Length should be 20.");
  return a2;
}
const je = (e2, t2, s2 = void 0) => function(e3, t3) {
  return e3.reduce((e4, s3, n2) => e4.concat(t3(s3, n2)), []);
}(e2, (e3) => {
  if ("string" == typeof e3) return t2(e3, s2);
  switch (e3.type) {
    case "bold":
    case "italic":
    case "strikethrough":
    case "blockquote":
    case "bulletlist":
    case "bulletList":
    case "bulletpoint":
    case "bulletPoint":
      return [{ type: e3.type, children: je(e3.children, t2, e3.type) }];
    case "link":
      return [{ type: e3.type, url: e3.url, children: je(e3.children, t2, e3.type) }];
    case "actionlink":
    case "actionLink":
    case "actionbutton":
    case "actionButton":
      return [{ type: e3.type, action: e3.action, params: e3.params, children: je(e3.children, t2, e3.type) }];
    case "mention":
    case "autolink":
    case "autoLink":
    case "codeblock":
    case "codeBlock":
    case "codespan":
    case "codeSpan":
    case "suppressed":
    case "emoji":
    case "customemoji":
    case "customEmoji":
      return [e3];
  }
});
function Ue(e2, t2) {
  return (s2) => {
    const n2 = s2;
    let r2 = 0;
    const i2 = [];
    for (const a2 of V(s2, e2)) {
      a2.index - r2 > 0 && i2.push(n2.substring(r2, a2.index));
      const e3 = t2(a2);
      Array.isArray(e3) ? i2.push(...e3) : i2.push(e3), r2 = a2.index + a2[0].length;
    }
    return r2 < s2.length && i2.push(s2.substring(r2)), i2;
  };
}
const $e = "â€™'()[]{}<>:,â€’â€“â€”â€•â€¦!.Â«Â»-â€?â€˜â€™â€œâ€;/â„â Â·&@*\\â€¢^Â¤Â¢$â‚¬Â£Â¥â‚©â‚ªâ€ â€¡Â°Â¡Â¿Â¬#â„–%â€°â€±Â¶â€²Â§~Â¨_|Â¦â‚â˜žâˆ´â€½â€»".replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var We = ((e2) => (e2[e2.italic = 1] = "italic", e2[e2.strikethrough = 2] = "strikethrough", e2[e2.bold = 4] = "bold", e2))(We || {});
const qe = [0, 1, 2, 3, 4, 5, 6].map((e2) => {
  const t2 = [];
  return 1 & e2 || t2.push(/_([^\s_].*?[^\s_])_|_([^\s_])_/), 2 & e2 || t2.push(/~([^\s~].*?[^\s~])~|~([^\s~])~/), 4 & e2 || t2.push(/\*([^\s*].*?[^\s*])\*|\*([^\s*])\*/), new RegExp(t2.map((e3) => e3.source).join("|"), "g");
}), He = { _: 1, "*": 4, "~": 2 };
function Le(e2) {
  return Ge(e2, 0);
}
function Ge(e2, t2 = 0) {
  const s2 = qe[t2], n2 = s2 ? function(e3) {
    const t3 = ze.getOrCompute(e3, () => new RegExp(`(?:^|[\\s${$e}])(?:${e3.source})(?=[\\s${$e}]|$)`, "g")), s3 = Ue(t3, (e4) => {
      const t4 = e4[0][1], s4 = e4[1] || e4[2] || e4[3] || e4[4] || e4[5] || e4[6];
      return [" ", { type: We[He[t4]], children: [s4] }];
    });
    return (e4) => {
      const [t4, ...n3] = s3(" " + e4);
      return t4.length > 1 && n3.unshift(t4.substring(1)), n3;
    };
  }(s2) : () => [e2];
  return je(n2(e2), (e3, s3) => "bold" === s3 || "italic" === s3 || "strikethrough" === s3 ? Ge(e3, t2 | We[s3]) : [e3]);
}
const ze = function() {
  const e2 = function() {
    try {
      return /* @__PURE__ */ new WeakMap();
    } catch (e3) {
      const t2 = { has: () => false, get: () => {
      }, set: () => t2 };
      return t2;
    }
  }();
  return { getOrCompute(t2, s2) {
    if (e2.has(t2)) return e2.get(t2);
    const n2 = s2();
    return e2.set(t2, n2), n2;
  } };
}();
function Je(e2, t2) {
  if (Array.prototype.indexOf) return e2.indexOf(t2);
  for (var s2 = 0, n2 = e2.length; s2 < n2; s2++) if (e2[s2] === t2) return s2;
  return -1;
}
function Ye(e2, t2) {
  for (var s2 = e2.length - 1; s2 >= 0; s2--) true === t2(e2[s2]) && e2.splice(s2, 1);
}
function Qe(e2) {
  throw new Error("Unhandled case for value: '" + e2 + "'");
}
var Ve = function() {
  function e2(e3) {
    void 0 === e3 && (e3 = {}), this.tagName = "", this.attrs = {}, this.innerHTML = "", this.whitespaceRegex = /\s+/, this.tagName = e3.tagName || "", this.attrs = e3.attrs || {}, this.innerHTML = e3.innerHtml || e3.innerHTML || "";
  }
  return e2.prototype.setTagName = function(e3) {
    return this.tagName = e3, this;
  }, e2.prototype.getTagName = function() {
    return this.tagName || "";
  }, e2.prototype.setAttr = function(e3, t2) {
    return this.getAttrs()[e3] = t2, this;
  }, e2.prototype.getAttr = function(e3) {
    return this.getAttrs()[e3];
  }, e2.prototype.setAttrs = function(e3) {
    return Object.assign(this.getAttrs(), e3), this;
  }, e2.prototype.getAttrs = function() {
    return this.attrs || (this.attrs = {});
  }, e2.prototype.setClass = function(e3) {
    return this.setAttr("class", e3);
  }, e2.prototype.addClass = function(e3) {
    for (var t2, s2 = this.getClass(), n2 = this.whitespaceRegex, r2 = s2 ? s2.split(n2) : [], i2 = e3.split(n2); t2 = i2.shift(); ) -1 === Je(r2, t2) && r2.push(t2);
    return this.getAttrs().class = r2.join(" "), this;
  }, e2.prototype.removeClass = function(e3) {
    for (var t2, s2 = this.getClass(), n2 = this.whitespaceRegex, r2 = s2 ? s2.split(n2) : [], i2 = e3.split(n2); r2.length && (t2 = i2.shift()); ) {
      var a2 = Je(r2, t2);
      -1 !== a2 && r2.splice(a2, 1);
    }
    return this.getAttrs().class = r2.join(" "), this;
  }, e2.prototype.getClass = function() {
    return this.getAttrs().class || "";
  }, e2.prototype.hasClass = function(e3) {
    return -1 !== (" " + this.getClass() + " ").indexOf(" " + e3 + " ");
  }, e2.prototype.setInnerHTML = function(e3) {
    return this.innerHTML = e3, this;
  }, e2.prototype.setInnerHtml = function(e3) {
    return this.setInnerHTML(e3);
  }, e2.prototype.getInnerHTML = function() {
    return this.innerHTML || "";
  }, e2.prototype.getInnerHtml = function() {
    return this.getInnerHTML();
  }, e2.prototype.toAnchorString = function() {
    var e3 = this.getTagName(), t2 = this.buildAttrsStr();
    return ["<", e3, t2 = t2 ? " " + t2 : "", ">", this.getInnerHtml(), "</", e3, ">"].join("");
  }, e2.prototype.buildAttrsStr = function() {
    if (!this.attrs) return "";
    var e3 = this.getAttrs(), t2 = [];
    for (var s2 in e3) e3.hasOwnProperty(s2) && t2.push(s2 + '="' + e3[s2] + '"');
    return t2.join(" ");
  }, e2;
}();
var Ze = function() {
  function e2(e3) {
    void 0 === e3 && (e3 = {}), this.newWindow = false, this.truncate = {}, this.className = "", this.newWindow = e3.newWindow || false, this.truncate = e3.truncate || {}, this.className = e3.className || "";
  }
  return e2.prototype.build = function(e3) {
    return new Ve({ tagName: "a", attrs: this.createAttrs(e3), innerHtml: this.processAnchorText(e3.getAnchorText()) });
  }, e2.prototype.createAttrs = function(e3) {
    var t2 = { href: e3.getAnchorHref() }, s2 = this.createCssClass(e3);
    return s2 && (t2.class = s2), this.newWindow && (t2.target = "_blank", t2.rel = "noopener noreferrer"), this.truncate && this.truncate.length && this.truncate.length < e3.getAnchorText().length && (t2.title = e3.getAnchorHref()), t2;
  }, e2.prototype.createCssClass = function(e3) {
    var t2 = this.className;
    if (t2) {
      for (var s2 = [t2], n2 = e3.getCssClassSuffixes(), r2 = 0, i2 = n2.length; r2 < i2; r2++) s2.push(t2 + "-" + n2[r2]);
      return s2.join(" ");
    }
    return "";
  }, e2.prototype.processAnchorText = function(e3) {
    return e3 = this.doTruncate(e3);
  }, e2.prototype.doTruncate = function(e3) {
    var t2 = this.truncate;
    if (!t2 || !t2.length) return e3;
    var s2 = t2.length, n2 = t2.location;
    return "smart" === n2 ? function(e4, t3, s3) {
      var n3, r2;
      null == s3 ? (s3 = "&hellip;", r2 = 3, n3 = 8) : (r2 = s3.length, n3 = s3.length);
      var i2 = function(e5) {
        var t4 = "";
        return e5.scheme && e5.host && (t4 += e5.scheme + "://"), e5.host && (t4 += e5.host), e5.path && (t4 += "/" + e5.path), e5.query && (t4 += "?" + e5.query), e5.fragment && (t4 += "#" + e5.fragment), t4;
      }, a2 = function(e5, t4) {
        var n4 = t4 / 2, r3 = Math.ceil(n4), i3 = -1 * Math.floor(n4), a3 = "";
        return i3 < 0 && (a3 = e5.substr(i3)), e5.substr(0, r3) + s3 + a3;
      };
      if (e4.length <= t3) return e4;
      var o2 = t3 - r2, u2 = function(e5) {
        var t4 = {}, s4 = e5, n4 = s4.match(/^([a-z]+):\/\//i);
        return n4 && (t4.scheme = n4[1], s4 = s4.substr(n4[0].length)), (n4 = s4.match(/^(.*?)(?=(\?|#|\/|$))/i)) && (t4.host = n4[1], s4 = s4.substr(n4[0].length)), (n4 = s4.match(/^\/(.*?)(?=(\?|#|$))/i)) && (t4.path = n4[1], s4 = s4.substr(n4[0].length)), (n4 = s4.match(/^\?(.*?)(?=(#|$))/i)) && (t4.query = n4[1], s4 = s4.substr(n4[0].length)), (n4 = s4.match(/^#(.*?)$/i)) && (t4.fragment = n4[1]), t4;
      }(e4);
      if (u2.query) {
        var c2 = u2.query.match(/^(.*?)(?=(\?|\#))(.*?)$/i);
        c2 && (u2.query = u2.query.substr(0, c2[1].length), e4 = i2(u2));
      }
      if (e4.length <= t3) return e4;
      if (u2.host && (u2.host = u2.host.replace(/^www\./, ""), e4 = i2(u2)), e4.length <= t3) return e4;
      var l2 = "";
      if (u2.host && (l2 += u2.host), l2.length >= o2) return u2.host.length == t3 ? (u2.host.substr(0, t3 - r2) + s3).substr(0, o2 + n3) : a2(l2, o2).substr(0, o2 + n3);
      var h2 = "";
      if (u2.path && (h2 += "/" + u2.path), u2.query && (h2 += "?" + u2.query), h2) {
        if ((l2 + h2).length >= o2) return (l2 + h2).length == t3 ? (l2 + h2).substr(0, t3) : (l2 + a2(h2, o2 - l2.length)).substr(0, o2 + n3);
        l2 += h2;
      }
      if (u2.fragment) {
        var d2 = "#" + u2.fragment;
        if ((l2 + d2).length >= o2) return (l2 + d2).length == t3 ? (l2 + d2).substr(0, t3) : (l2 + a2(d2, o2 - l2.length)).substr(0, o2 + n3);
        l2 += d2;
      }
      if (u2.scheme && u2.host) {
        var p2 = u2.scheme + "://";
        if ((l2 + p2).length < o2) return (p2 + l2).substr(0, t3);
      }
      if (l2.length <= t3) return l2;
      var f2 = "";
      return o2 > 0 && (f2 = l2.substr(-1 * Math.floor(o2 / 2))), (l2.substr(0, Math.ceil(o2 / 2)) + s3 + f2).substr(0, o2 + n3);
    }(e3, s2) : "middle" === n2 ? function(e4, t3, s3) {
      if (e4.length <= t3) return e4;
      var n3, r2;
      null == s3 ? (s3 = "&hellip;", n3 = 8, r2 = 3) : (n3 = s3.length, r2 = s3.length);
      var i2 = t3 - r2, a2 = "";
      return i2 > 0 && (a2 = e4.substr(-1 * Math.floor(i2 / 2))), (e4.substr(0, Math.ceil(i2 / 2)) + s3 + a2).substr(0, i2 + n3);
    }(e3, s2) : function(e4, t3, s3) {
      return function(e5, t4, s4) {
        var n3;
        return e5.length > t4 && (null == s4 ? (s4 = "&hellip;", n3 = 3) : n3 = s4.length, e5 = e5.substring(0, t4 - n3) + s4), e5;
      }(e4, t3, s3);
    }(e3, s2);
  }, e2;
}(), Ke = function() {
  function e2(e3) {
    this.__jsduckDummyDocProp = null, this.matchedText = "", this.offset = 0, this.tagBuilder = e3.tagBuilder, this.matchedText = e3.matchedText, this.offset = e3.offset;
  }
  return e2.prototype.getMatchedText = function() {
    return this.matchedText;
  }, e2.prototype.setOffset = function(e3) {
    this.offset = e3;
  }, e2.prototype.getOffset = function() {
    return this.offset;
  }, e2.prototype.getCssClassSuffixes = function() {
    return [this.getType()];
  }, e2.prototype.buildTag = function() {
    return this.tagBuilder.build(this);
  }, e2;
}(), Xe = function(e2, t2) {
  return Xe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
    e3.__proto__ = t3;
  } || function(e3, t3) {
    for (var s2 in t3) t3.hasOwnProperty(s2) && (e3[s2] = t3[s2]);
  }, Xe(e2, t2);
};
function et(e2, t2) {
  function s2() {
    this.constructor = e2;
  }
  Xe(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (s2.prototype = t2.prototype, new s2());
}
var tt, st = function() {
  return st = Object.assign || function(e2) {
    for (var t2, s2 = 1, n2 = arguments.length; s2 < n2; s2++) for (var r2 in t2 = arguments[s2]) Object.prototype.hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
    return e2;
  }, st.apply(this, arguments);
}, nt = function(e2) {
  function t2(t3) {
    var s2 = e2.call(this, t3) || this;
    return s2.email = "", s2.email = t3.email, s2;
  }
  return et(t2, e2), t2.prototype.getType = function() {
    return "email";
  }, t2.prototype.getEmail = function() {
    return this.email;
  }, t2.prototype.getAnchorHref = function() {
    return "mailto:" + this.email;
  }, t2.prototype.getAnchorText = function() {
    return this.email;
  }, t2;
}(Ke), rt = function(e2) {
  function t2(t3) {
    var s2 = e2.call(this, t3) || this;
    return s2.serviceName = "", s2.hashtag = "", s2.serviceName = t3.serviceName, s2.hashtag = t3.hashtag, s2;
  }
  return et(t2, e2), t2.prototype.getType = function() {
    return "hashtag";
  }, t2.prototype.getServiceName = function() {
    return this.serviceName;
  }, t2.prototype.getHashtag = function() {
    return this.hashtag;
  }, t2.prototype.getAnchorHref = function() {
    var e3 = this.serviceName, t3 = this.hashtag;
    switch (e3) {
      case "twitter":
        return "https://twitter.com/hashtag/" + t3;
      case "facebook":
        return "https://www.facebook.com/hashtag/" + t3;
      case "instagram":
        return "https://instagram.com/explore/tags/" + t3;
      default:
        throw new Error("Unknown service name to point hashtag to: " + e3);
    }
  }, t2.prototype.getAnchorText = function() {
    return "#" + this.hashtag;
  }, t2;
}(Ke), it = function(e2) {
  function t2(t3) {
    var s2 = e2.call(this, t3) || this;
    return s2.serviceName = "twitter", s2.mention = "", s2.mention = t3.mention, s2.serviceName = t3.serviceName, s2;
  }
  return et(t2, e2), t2.prototype.getType = function() {
    return "mention";
  }, t2.prototype.getMention = function() {
    return this.mention;
  }, t2.prototype.getServiceName = function() {
    return this.serviceName;
  }, t2.prototype.getAnchorHref = function() {
    switch (this.serviceName) {
      case "twitter":
        return "https://twitter.com/" + this.mention;
      case "instagram":
        return "https://instagram.com/" + this.mention;
      case "soundcloud":
        return "https://soundcloud.com/" + this.mention;
      default:
        throw new Error("Unknown service name to point mention to: " + this.serviceName);
    }
  }, t2.prototype.getAnchorText = function() {
    return "@" + this.mention;
  }, t2.prototype.getCssClassSuffixes = function() {
    var t3 = e2.prototype.getCssClassSuffixes.call(this), s2 = this.getServiceName();
    return s2 && t3.push(s2), t3;
  }, t2;
}(Ke), at = function(e2) {
  function t2(t3) {
    var s2 = e2.call(this, t3) || this;
    return s2.number = "", s2.plusSign = false, s2.number = t3.number, s2.plusSign = t3.plusSign, s2;
  }
  return et(t2, e2), t2.prototype.getType = function() {
    return "phone";
  }, t2.prototype.getPhoneNumber = function() {
    return this.number;
  }, t2.prototype.getNumber = function() {
    return this.getPhoneNumber();
  }, t2.prototype.getAnchorHref = function() {
    return "tel:" + (this.plusSign ? "+" : "") + this.number;
  }, t2.prototype.getAnchorText = function() {
    return this.matchedText;
  }, t2;
}(Ke), ot = function(e2) {
  function t2(t3) {
    var s2 = e2.call(this, t3) || this;
    return s2.url = "", s2.urlMatchType = "scheme", s2.protocolUrlMatch = false, s2.protocolRelativeMatch = false, s2.stripPrefix = { scheme: true, www: true }, s2.stripTrailingSlash = true, s2.decodePercentEncoding = true, s2.schemePrefixRegex = /^(https?:\/\/)?/i, s2.wwwPrefixRegex = /^(https?:\/\/)?(www\.)?/i, s2.protocolRelativeRegex = /^\/\//, s2.protocolPrepended = false, s2.urlMatchType = t3.urlMatchType, s2.url = t3.url, s2.protocolUrlMatch = t3.protocolUrlMatch, s2.protocolRelativeMatch = t3.protocolRelativeMatch, s2.stripPrefix = t3.stripPrefix, s2.stripTrailingSlash = t3.stripTrailingSlash, s2.decodePercentEncoding = t3.decodePercentEncoding, s2;
  }
  return et(t2, e2), t2.prototype.getType = function() {
    return "url";
  }, t2.prototype.getUrlMatchType = function() {
    return this.urlMatchType;
  }, t2.prototype.getUrl = function() {
    var e3 = this.url;
    return this.protocolRelativeMatch || this.protocolUrlMatch || this.protocolPrepended || (e3 = this.url = "http://" + e3, this.protocolPrepended = true), e3;
  }, t2.prototype.getAnchorHref = function() {
    return this.getUrl().replace(/&amp;/g, "&");
  }, t2.prototype.getAnchorText = function() {
    var e3 = this.getMatchedText();
    return this.protocolRelativeMatch && (e3 = this.stripProtocolRelativePrefix(e3)), this.stripPrefix.scheme && (e3 = this.stripSchemePrefix(e3)), this.stripPrefix.www && (e3 = this.stripWwwPrefix(e3)), this.stripTrailingSlash && (e3 = this.removeTrailingSlash(e3)), this.decodePercentEncoding && (e3 = this.removePercentEncoding(e3)), e3;
  }, t2.prototype.stripSchemePrefix = function(e3) {
    return e3.replace(this.schemePrefixRegex, "");
  }, t2.prototype.stripWwwPrefix = function(e3) {
    return e3.replace(this.wwwPrefixRegex, "$1");
  }, t2.prototype.stripProtocolRelativePrefix = function(e3) {
    return e3.replace(this.protocolRelativeRegex, "");
  }, t2.prototype.removeTrailingSlash = function(e3) {
    return "/" === e3.charAt(e3.length - 1) && (e3 = e3.slice(0, -1)), e3;
  }, t2.prototype.removePercentEncoding = function(e3) {
    var t3 = e3.replace(/%22/gi, "&quot;").replace(/%26/gi, "&amp;").replace(/%27/gi, "&#39;").replace(/%3C/gi, "&lt;").replace(/%3E/gi, "&gt;");
    try {
      return decodeURIComponent(t3);
    } catch (e4) {
      return t3;
    }
  }, t2;
}(Ke), ut = function(e2) {
  this.__jsduckDummyDocProp = null, this.tagBuilder = e2.tagBuilder;
}, ct = /[A-Za-z]/, lt = /[\d]/, ht = /[\D]/, dt = /\s/, pt = /['"]/, ft = /[\x00-\x1F\x7F]/, mt = /A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC/.source, gt = mt + /\u2700-\u27bf\udde6-\uddff\ud800-\udbff\udc00-\udfff\ufe0e\ufe0f\u0300-\u036f\ufe20-\ufe23\u20d0-\u20f0\ud83c\udffb-\udfff\u200d\u3299\u3297\u303d\u3030\u24c2\ud83c\udd70-\udd71\udd7e-\udd7f\udd8e\udd91-\udd9a\udde6-\uddff\ude01-\ude02\ude1a\ude2f\ude32-\ude3a\ude50-\ude51\u203c\u2049\u25aa-\u25ab\u25b6\u25c0\u25fb-\u25fe\u00a9\u00ae\u2122\u2139\udc04\u2600-\u26FF\u2b05\u2b06\u2b07\u2b1b\u2b1c\u2b50\u2b55\u231a\u231b\u2328\u23cf\u23e9-\u23f3\u23f8-\u23fa\udccf\u2935\u2934\u2190-\u21ff/.source + /\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F/.source, vt = /0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19/.source, wt = gt + vt, bt = gt + vt, yt = "(?:[" + vt + "]{1,3}\\.){3}[" + vt + "]{1,3}", Ct = "[" + bt + "](?:[" + bt + "\\-]{0,61}[" + bt + "])?", At = function(e2) {
  return "(?=(" + Ct + "))\\" + e2;
}, Et = function(e2) {
  return "(?:" + At(e2) + "(?:\\." + At(e2 + 1) + "){0,126}|" + yt + ")";
}, kt = new RegExp("[" + bt + "]"), xt = /(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|northwesternmutual|travelersinsurance|vermÃ¶gensberatung|xn--3oq18vl8pn36a|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermÃ¶gensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbaakc7dvf|xn--mgbc0a9azcg|xn--nqv7fs00ema|afamilycompany|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--h2breg3eve|xn--jlq61u9w7b|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbb9fbpob|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|xn--rvc1e0am3e|international|lifeinsurance|spreadbetting|travelchannel|wolterskluwer|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--h2brj9c8c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|scholarships|versicherung|xn--3e0b707e|xn--45br5cyl|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbgu82a|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|rightathome|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--3bst00m|xn--3ds443g|xn--3hcrj9c|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--estv75g|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--kpu716f|xn--mgbbh1a|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--otu796d|xn--pbt977c|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b|à®šà®¿à®™à¯à®•à®ªà¯à®ªà¯‚à®°à¯|accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nationwide|newholland|nextdirect|onyourside|properties|protection|prudential|realestate|republican|restaurant|schaeffler|swiftcover|tatamotors|technology|telefonica|university|vistaprint|vlaanderen|volkswagen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|fujixerox|furniture|goldpoint|hisamitsu|homedepot|homegoods|homesense|honeywell|institute|insurance|kuokgroup|ladbrokes|lancaster|landrover|lifestyle|marketing|marshalls|melbourne|microsoft|panasonic|passagens|pramerica|richardli|scjohnson|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--ngbrx|xn--nqv7f|xn--p1acf|xn--tckwe|xn--vhquv|yodobashi|abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|budapest|builders|business|capetown|catering|catholic|chrysler|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|esurance|etisalat|everbank|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|merckmsd|mortgage|movistar|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|symantec|training|uconnect|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama|Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©|abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|cartier|channel|charity|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|grocery|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|iselect|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lancome|lanxess|lasalle|latrobe|leclerc|liaison|limited|lincoln|markets|metlife|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|shriram|singles|staples|starhub|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|yamaxun|youtube|zuerich|ÐºÐ°Ñ‚Ð¾Ð»Ð¸Ðº|Ø§ØªØµØ§Ù„Ø§Øª|Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±|Ø§Ù„Ø¹Ù„ÙŠØ§Ù†|Ù¾Ø§Ú©Ø³ØªØ§Ù†|ÙƒØ§Ø«ÙˆÙ„ÙŠÙƒ|Ù…ÙˆØ¨Ø§ÙŠÙ„ÙŠ|à®‡à®¨à¯à®¤à®¿à®¯à®¾|abarth|abbott|abbvie|active|africa|agency|airbus|airtel|alipay|alsace|alstom|anquan|aramco|author|bayern|beauty|berlin|bharti|blanco|bostik|boston|broker|camera|career|caseih|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hotels|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|mobily|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|piaget|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|search|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|warman|webcam|xihuan|yachts|yandex|zappos|Ð¼Ð¾ÑÐºÐ²Ð°|Ð¾Ð½Ð»Ð°Ð¹Ð½|Ø§Ø¨ÙˆØ¸Ø¨ÙŠ|Ø§Ø±Ø§Ù…ÙƒÙˆ|Ø§Ù„Ø§Ø±Ø¯Ù†|Ø§Ù„Ù…ØºØ±Ø¨|Ø§Ù…Ø§Ø±Ø§Øª|ÙÙ„Ø³Ø·ÙŠÙ†|Ù…Ù„ÙŠØ³ÙŠØ§|à¤­à¤¾à¤°à¤¤à¤®à¥|à®‡à®²à®™à¯à®•à¯ˆ|ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³|actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|bosch|build|canon|cards|chase|cheap|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|dodge|drive|dubai|earth|edeka|email|epost|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glade|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|intel|irish|iveco|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|lixil|loans|locus|lotte|lotto|lupin|macys|mango|media|miami|money|mopar|movie|nadex|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|rugby|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|sport|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo|zippo|Ø§ÛŒØ±Ø§Ù†|Ø¨Ø§Ø²Ø§Ø±|Ø¨Ú¾Ø§Ø±Øª|Ø³ÙˆØ¯Ø§Ù†|Ø³ÙˆØ±ÙŠØ©|Ù‡Ù…Ø±Ø§Ù‡|à¤­à¤¾à¤°à¥‹à¤¤|à¤¸à¤‚à¤—à¤ à¤¨|à¦¬à¦¾à¦‚à¦²à¦¾|à°­à°¾à°°à°¤à±|à´­à´¾à´°à´¤à´‚|å˜‰é‡Œå¤§é…’åº—|aarp|able|adac|aero|aigo|akdn|ally|amex|arab|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|doha|duck|duns|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|raid|read|reit|rent|rest|rich|rmit|room|rsvp|ruhr|safe|sale|sarl|save|saxo|scor|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone|Ð´ÐµÑ‚Ð¸|ÑÐ°Ð¹Ñ‚|Ø¨Ø§Ø±Øª|Ø¨ÙŠØªÙƒ|Ú€Ø§Ø±Øª|ØªÙˆÙ†Ø³|Ø´Ø¨ÙƒØ©|Ø¹Ø±Ø§Ù‚|Ø¹Ù…Ø§Ù†|Ù…ÙˆÙ‚Ø¹|à¤­à¤¾à¤°à¤¤|à¦­à¦¾à¦°à¦¤|à¦­à¦¾à§°à¦¤|à¨­à¨¾à¨°à¨¤|àª­àª¾àª°àª¤|à¬­à¬¾à¬°à¬¤|à²­à²¾à²°à²¤|à¶½à¶‚à¶šà·|ã‚°ãƒ¼ã‚°ãƒ«|ã‚¯ãƒ©ã‚¦ãƒ‰|ãƒã‚¤ãƒ³ãƒˆ|å¤§ä¼—æ±½è½¦|ç»„ç»‡æœºæž„|é›»è¨Šç›ˆç§‘|é¦™æ ¼é‡Œæ‹‰|aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bnl|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceb|ceo|cfa|cfd|com|crs|csc|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|ibm|ice|icu|ifm|inc|ing|ink|int|ist|itv|jcb|jcp|jio|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|llc|lol|lpl|ltd|man|map|mba|med|men|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|off|one|ong|onl|ooo|org|ott|ovh|pay|pet|phd|pid|pin|pnc|pro|pru|pub|pwc|qvc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|srl|srt|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip|Ð±ÐµÐ»|ÐºÐ¾Ð¼|Ò›Ð°Ð·|Ð¼ÐºÐ´|Ð¼Ð¾Ð½|Ð¾Ñ€Ð³|Ñ€ÑƒÑ|ÑÑ€Ð±|ÑƒÐºÑ€|Õ°Õ¡Õµ|×§×•×|Ø¹Ø±Ø¨|Ù‚Ø·Ø±|ÙƒÙˆÙ…|Ù…ØµØ±|à¤•à¥‰à¤®|à¤¨à¥‡à¤Ÿ|à¸„à¸­à¸¡|à¹„à¸—à¸¢|ã‚¹ãƒˆã‚¢|ã‚»ãƒ¼ãƒ«|ã¿ã‚“ãª|ä¸­æ–‡ç½‘|å¤©ä¸»æ•™|æˆ‘çˆ±ä½ |æ–°åŠ å¡|æ·¡é©¬é”¡|è¯ºåŸºäºš|é£žåˆ©æµ¦|ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw|ÎµÎ»|Ð±Ð³|ÐµÑŽ|Ñ€Ñ„|áƒ’áƒ”|ë‹·ë„·|ë‹·ì»´|ì‚¼ì„±|í•œêµ­|ã‚³ãƒ |ä¸–ç•Œ|ä¸­ä¿¡|ä¸­å›½|ä¸­åœ‹|ä¼ä¸š|ä½›å±±|ä¿¡æ¯|å¥åº·|å…«å¦|å…¬å¸|å…¬ç›Š|å°æ¹¾|å°ç£|å•†åŸŽ|å•†åº—|å•†æ ‡|å˜‰é‡Œ|åœ¨çº¿|å¤§æ‹¿|å¨±ä¹|å®¶é›»|å·¥è¡Œ|å¹¿ä¸œ|å¾®åš|æ…ˆå–„|æ‰‹æœº|æ‰‹è¡¨|æ‹›è˜|æ”¿åŠ¡|æ”¿åºœ|æ–°é—»|æ—¶å°š|æ›¸ç±|æœºæž„|æ¸¸æˆ|æ¾³é–€|ç‚¹çœ‹|ç å®|ç§»åŠ¨|ç½‘å€|ç½‘åº—|ç½‘ç«™|ç½‘ç»œ|è”é€š|è°·æ­Œ|è´­ç‰©|é€šè²©|é›†å›¢|é£Ÿå“|é¤åŽ…|é¦™æ¸¯)/, It = new RegExp("[" + bt + "!#$%&'*+/=?^_`{|}~-]"), Tt = new RegExp("^" + xt.source + "$"), Dt = function(e2) {
  function t2() {
    var t3 = null !== e2 && e2.apply(this, arguments) || this;
    return t3.localPartCharRegex = It, t3.strictTldRegex = Tt, t3;
  }
  return et(t2, e2), t2.prototype.parseMatches = function(e3) {
    for (var t3 = this.tagBuilder, s2 = this.localPartCharRegex, n2 = this.strictTldRegex, r2 = [], i2 = e3.length, a2 = new St(), o2 = { m: "a", a: "i", i: "l", l: "t", t: "o", o: ":" }, u2 = 0, c2 = 0, l2 = a2; u2 < i2; ) {
      var h2 = e3.charAt(u2);
      switch (c2) {
        case 0:
          d2(h2);
          break;
        case 1:
          p2(e3.charAt(u2 - 1), h2);
          break;
        case 2:
          f2(h2);
          break;
        case 3:
          m2(h2);
          break;
        case 4:
          g2(h2);
          break;
        case 5:
          v2(h2);
          break;
        case 6:
          w2(h2);
          break;
        case 7:
          b2(h2);
          break;
        default:
          Qe(c2);
      }
      u2++;
    }
    return A2(), r2;
    function d2(e4) {
      "m" === e4 ? y2(1) : s2.test(e4) && y2();
    }
    function p2(e4, t4) {
      ":" === e4 ? s2.test(t4) ? (c2 = 2, l2 = new St(st(st({}, l2), { hasMailtoPrefix: true }))) : C2() : o2[e4] === t4 || (s2.test(t4) ? c2 = 2 : "." === t4 ? c2 = 3 : "@" === t4 ? c2 = 4 : C2());
    }
    function f2(e4) {
      "." === e4 ? c2 = 3 : "@" === e4 ? c2 = 4 : s2.test(e4) || C2();
    }
    function m2(e4) {
      "." === e4 || "@" === e4 ? C2() : s2.test(e4) ? c2 = 2 : C2();
    }
    function g2(e4) {
      kt.test(e4) ? c2 = 5 : C2();
    }
    function v2(e4) {
      "." === e4 ? c2 = 7 : "-" === e4 ? c2 = 6 : kt.test(e4) || A2();
    }
    function w2(e4) {
      "-" === e4 || "." === e4 ? A2() : kt.test(e4) ? c2 = 5 : A2();
    }
    function b2(e4) {
      "." === e4 || "-" === e4 ? A2() : kt.test(e4) ? (c2 = 5, l2 = new St(st(st({}, l2), { hasDomainDot: true }))) : A2();
    }
    function y2(e4) {
      void 0 === e4 && (e4 = 2), c2 = e4, l2 = new St({ idx: u2 });
    }
    function C2() {
      c2 = 0, l2 = a2;
    }
    function A2() {
      if (l2.hasDomainDot) {
        var s3 = e3.slice(l2.idx, u2);
        /[-.]$/.test(s3) && (s3 = s3.slice(0, -1));
        var i3 = l2.hasMailtoPrefix ? s3.slice(7) : s3;
        (function(e4) {
          var t4 = e4.split(".").pop() || "", s4 = t4.toLowerCase();
          return n2.test(s4);
        })(i3) && r2.push(new nt({ tagBuilder: t3, matchedText: s3, offset: l2.idx, email: i3 }));
      }
      C2();
    }
  }, t2;
}(ut), St = function(e2) {
  void 0 === e2 && (e2 = {}), this.idx = void 0 !== e2.idx ? e2.idx : -1, this.hasMailtoPrefix = !!e2.hasMailtoPrefix, this.hasDomainDot = !!e2.hasDomainDot;
}, Mt = function() {
  function e2() {
  }
  return e2.isValid = function(e3, t2) {
    return !(t2 && !this.isValidUriScheme(t2) || this.urlMatchDoesNotHaveProtocolOrDot(e3, t2) || this.urlMatchDoesNotHaveAtLeastOneWordChar(e3, t2) && !this.isValidIpAddress(e3) || this.containsMultipleDots(e3));
  }, e2.isValidIpAddress = function(e3) {
    var t2 = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);
    return null !== e3.match(t2);
  }, e2.containsMultipleDots = function(e3) {
    var t2 = e3;
    return this.hasFullProtocolRegex.test(e3) && (t2 = e3.split("://")[1]), t2.split("/")[0].indexOf("..") > -1;
  }, e2.isValidUriScheme = function(e3) {
    var t2 = e3.match(this.uriSchemeRegex), s2 = t2 && t2[0].toLowerCase();
    return "javascript:" !== s2 && "vbscript:" !== s2;
  }, e2.urlMatchDoesNotHaveProtocolOrDot = function(e3, t2) {
    return !(!e3 || t2 && this.hasFullProtocolRegex.test(t2) || -1 !== e3.indexOf("."));
  }, e2.urlMatchDoesNotHaveAtLeastOneWordChar = function(e3, t2) {
    return !(!e3 || !t2) && (!this.hasFullProtocolRegex.test(t2) && !this.hasWordCharAfterProtocolRegex.test(e3));
  }, e2.hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\/\//, e2.uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/, e2.hasWordCharAfterProtocolRegex = new RegExp(":[^\\s]*?[" + mt + "]"), e2.ipRegex = /[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?(:[0-9]*)?\/?$/, e2;
}(), Ft = (tt = new RegExp("[/?#](?:[" + bt + "\\-+&@#/%=~_()|'$*\\[\\]{}?!:,.;^âœ“]*[" + bt + "\\-+&@#/%=~_()|'$*\\[\\]{}âœ“])?"), new RegExp(["(?:", "(", /(?:[A-Za-z][-.+A-Za-z0-9]{0,63}:(?![A-Za-z][-.+A-Za-z0-9]{0,63}:\/\/)(?!\d+\/?)(?:\/\/)?)/.source, Et(2), ")", "|", "(", "(//)?", /(?:www\.)/.source, Et(6), ")", "|", "(", "(//)?", Et(10) + "\\.", xt.source, "(?![-" + wt + "])", ")", ")", "(?::[0-9]+)?", "(?:" + tt.source + ")?"].join(""), "gi")), Bt = new RegExp("[" + bt + "]"), Rt = function(e2) {
  function t2(t3) {
    var s2 = e2.call(this, t3) || this;
    return s2.stripPrefix = { scheme: true, www: true }, s2.stripTrailingSlash = true, s2.decodePercentEncoding = true, s2.matcherRegex = Ft, s2.wordCharRegExp = Bt, s2.stripPrefix = t3.stripPrefix, s2.stripTrailingSlash = t3.stripTrailingSlash, s2.decodePercentEncoding = t3.decodePercentEncoding, s2;
  }
  return et(t2, e2), t2.prototype.parseMatches = function(e3) {
    for (var t3, s2 = this.matcherRegex, n2 = this.stripPrefix, r2 = this.stripTrailingSlash, i2 = this.decodePercentEncoding, a2 = this.tagBuilder, o2 = [], u2 = function() {
      var s3 = t3[0], u3 = t3[1], l2 = t3[4], h2 = t3[5], d2 = t3[9], p2 = t3.index, f2 = h2 || d2, m2 = e3.charAt(p2 - 1);
      if (!Mt.isValid(s3, u3)) return "continue";
      if (p2 > 0 && "@" === m2) return "continue";
      if (p2 > 0 && f2 && c2.wordCharRegExp.test(m2)) return "continue";
      if (/\?$/.test(s3) && (s3 = s3.substr(0, s3.length - 1)), c2.matchHasUnbalancedClosingParen(s3)) s3 = s3.substr(0, s3.length - 1);
      else {
        var g2 = c2.matchHasInvalidCharAfterTld(s3, u3);
        g2 > -1 && (s3 = s3.substr(0, g2));
      }
      var v2 = ["http://", "https://"].find(function(e4) {
        return !!u3 && -1 !== u3.indexOf(e4);
      });
      if (v2) {
        var w2 = s3.indexOf(v2);
        s3 = s3.substr(w2), u3 = u3.substr(w2), p2 += w2;
      }
      var b2 = u3 ? "scheme" : l2 ? "www" : "tld", y2 = !!u3;
      o2.push(new ot({ tagBuilder: a2, matchedText: s3, offset: p2, urlMatchType: b2, url: s3, protocolUrlMatch: y2, protocolRelativeMatch: !!f2, stripPrefix: n2, stripTrailingSlash: r2, decodePercentEncoding: i2 }));
    }, c2 = this; null !== (t3 = s2.exec(e3)); ) u2();
    return o2;
  }, t2.prototype.matchHasUnbalancedClosingParen = function(e3) {
    var t3, s2 = e3.charAt(e3.length - 1);
    if (")" === s2) t3 = "(";
    else if ("]" === s2) t3 = "[";
    else {
      if ("}" !== s2) return false;
      t3 = "{";
    }
    for (var n2 = 0, r2 = 0, i2 = e3.length - 1; r2 < i2; r2++) {
      var a2 = e3.charAt(r2);
      a2 === t3 ? n2++ : a2 === s2 && (n2 = Math.max(n2 - 1, 0));
    }
    return 0 === n2;
  }, t2.prototype.matchHasInvalidCharAfterTld = function(e3, t3) {
    if (!e3) return -1;
    var s2 = 0;
    t3 && (s2 = e3.indexOf(":"), e3 = e3.slice(s2));
    var n2 = new RegExp("^((.?//)?[-." + bt + "]*[-" + bt + "]\\.[-" + bt + "]+)").exec(e3);
    return null === n2 ? -1 : (s2 += n2[1].length, e3 = e3.slice(n2[1].length), /^[^-.A-Za-z0-9:\/?#]/.test(e3) ? s2 : -1);
  }, t2;
}(ut), Nt = new RegExp("#[_" + bt + "]{1,139}(?![_" + bt + "])", "g"), _t = new RegExp("[^" + bt + "]"), Pt = function(e2) {
  function t2(t3) {
    var s2 = e2.call(this, t3) || this;
    return s2.serviceName = "twitter", s2.matcherRegex = Nt, s2.nonWordCharRegex = _t, s2.serviceName = t3.serviceName, s2;
  }
  return et(t2, e2), t2.prototype.parseMatches = function(e3) {
    for (var t3, s2 = this.matcherRegex, n2 = this.nonWordCharRegex, r2 = this.serviceName, i2 = this.tagBuilder, a2 = []; null !== (t3 = s2.exec(e3)); ) {
      var o2 = t3.index, u2 = e3.charAt(o2 - 1);
      if (0 === o2 || n2.test(u2)) {
        var c2 = t3[0], l2 = t3[0].slice(1);
        a2.push(new rt({ tagBuilder: i2, matchedText: c2, offset: o2, serviceName: r2, hashtag: l2 }));
      }
    }
    return a2;
  }, t2;
}(ut), Ot = new RegExp(/(?:(?:(?:(\+)?\d{1,3}[-\040.]?)?\(?\d{3}\)?[-\040.]?\d{3}[-\040.]?\d{4})|(?:(\+)(?:9[976]\d|8[987530]\d|6[987]\d|5[90]\d|42\d|3[875]\d|2[98654321]\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-\040.]?(?:\d[-\040.]?){6,12}\d+))([,;]+[0-9]+#?)*/.source + "|" + /(0([1-9]{1}-?[1-9]\d{3}|[1-9]{2}-?\d{3}|[1-9]{2}\d{1}-?\d{2}|[1-9]{2}\d{2}-?\d{1})-?\d{4}|0[789]0-?\d{4}-?\d{4}|050-?\d{4}-?\d{4})/.source, "g"), jt = function(e2) {
  function t2() {
    var t3 = null !== e2 && e2.apply(this, arguments) || this;
    return t3.matcherRegex = Ot, t3;
  }
  return et(t2, e2), t2.prototype.parseMatches = function(e3) {
    for (var t3, s2 = this.matcherRegex, n2 = this.tagBuilder, r2 = []; null !== (t3 = s2.exec(e3)); ) {
      var i2 = t3[0], a2 = i2.replace(/[^0-9,;#]/g, ""), o2 = !(!t3[1] && !t3[2]), u2 = 0 == t3.index ? "" : e3.substr(t3.index - 1, 1), c2 = e3.substr(t3.index + i2.length, 1), l2 = !u2.match(/\d/) && !c2.match(/\d/);
      this.testMatch(t3[3]) && this.testMatch(i2) && l2 && r2.push(new at({ tagBuilder: n2, matchedText: i2, offset: t3.index, number: a2, plusSign: o2 }));
    }
    return r2;
  }, t2.prototype.testMatch = function(e3) {
    return ht.test(e3);
  }, t2;
}(ut), Ut = new RegExp("@[_" + bt + "]{1,50}(?![_" + bt + "])", "g"), $t = new RegExp("@[_." + bt + "]{1,30}(?![_" + bt + "])", "g"), Wt = new RegExp("@[-_." + bt + "]{1,50}(?![-_" + bt + "])", "g"), qt = new RegExp("[^" + bt + "]"), Ht = function(e2) {
  function t2(t3) {
    var s2 = e2.call(this, t3) || this;
    return s2.serviceName = "twitter", s2.matcherRegexes = { twitter: Ut, instagram: $t, soundcloud: Wt }, s2.nonWordCharRegex = qt, s2.serviceName = t3.serviceName, s2;
  }
  return et(t2, e2), t2.prototype.parseMatches = function(e3) {
    var t3, s2 = this.serviceName, n2 = this.matcherRegexes[this.serviceName], r2 = this.nonWordCharRegex, i2 = this.tagBuilder, a2 = [];
    if (!n2) return a2;
    for (; null !== (t3 = n2.exec(e3)); ) {
      var o2 = t3.index, u2 = e3.charAt(o2 - 1);
      if (0 === o2 || r2.test(u2)) {
        var c2 = t3[0].replace(/\.+$/g, ""), l2 = c2.slice(1);
        a2.push(new it({ tagBuilder: i2, matchedText: c2, offset: o2, serviceName: s2, mention: l2 }));
      }
    }
    return a2;
  }, t2;
}(ut);
function Lt(e2, t2) {
  for (var s2, n2 = t2.onOpenTag, r2 = t2.onCloseTag, i2 = t2.onText, a2 = t2.onComment, o2 = t2.onDoctype, u2 = new Gt(), c2 = 0, l2 = e2.length, h2 = 0, d2 = 0, p2 = u2; c2 < l2; ) {
    var f2 = e2.charAt(c2);
    switch (h2) {
      case 0:
        m2(f2);
        break;
      case 1:
        g2(f2);
        break;
      case 2:
        w2(f2);
        break;
      case 3:
        v2(f2);
        break;
      case 4:
        b2(f2);
        break;
      case 5:
        y2(f2);
        break;
      case 6:
        C2(f2);
        break;
      case 7:
        A2(f2);
        break;
      case 8:
        E2(f2);
        break;
      case 9:
        k2(f2);
        break;
      case 10:
        x2(f2);
        break;
      case 11:
        I2(f2);
        break;
      case 12:
        T2(f2);
        break;
      case 13:
        D2();
        break;
      case 14:
        S2(f2);
        break;
      case 15:
        M2(f2);
        break;
      case 16:
        F2(f2);
        break;
      case 17:
        B2(f2);
        break;
      case 18:
        R2(f2);
        break;
      case 19:
        N2(f2);
        break;
      case 20:
        _2(f2);
        break;
      default:
        Qe(h2);
    }
    c2++;
  }
  function m2(e3) {
    "<" === e3 && O2();
  }
  function g2(e3) {
    "!" === e3 ? h2 = 13 : "/" === e3 ? (h2 = 2, p2 = new Gt(st(st({}, p2), { isClosing: true }))) : "<" === e3 ? O2() : ct.test(e3) ? (h2 = 3, p2 = new Gt(st(st({}, p2), { isOpening: true }))) : (h2 = 0, p2 = u2);
  }
  function v2(e3) {
    dt.test(e3) ? (p2 = new Gt(st(st({}, p2), { name: U2() })), h2 = 4) : "<" === e3 ? O2() : "/" === e3 ? (p2 = new Gt(st(st({}, p2), { name: U2() })), h2 = 12) : ">" === e3 ? (p2 = new Gt(st(st({}, p2), { name: U2() })), j2()) : ct.test(e3) || lt.test(e3) || ":" === e3 || P2();
  }
  function w2(e3) {
    ">" === e3 ? P2() : ct.test(e3) ? h2 = 3 : P2();
  }
  function b2(e3) {
    dt.test(e3) || ("/" === e3 ? h2 = 12 : ">" === e3 ? j2() : "<" === e3 ? O2() : "=" === e3 || pt.test(e3) || ft.test(e3) ? P2() : h2 = 5);
  }
  function y2(e3) {
    dt.test(e3) ? h2 = 6 : "/" === e3 ? h2 = 12 : "=" === e3 ? h2 = 7 : ">" === e3 ? j2() : "<" === e3 ? O2() : pt.test(e3) && P2();
  }
  function C2(e3) {
    dt.test(e3) || ("/" === e3 ? h2 = 12 : "=" === e3 ? h2 = 7 : ">" === e3 ? j2() : "<" === e3 ? O2() : pt.test(e3) ? P2() : h2 = 5);
  }
  function A2(e3) {
    dt.test(e3) || ('"' === e3 ? h2 = 8 : "'" === e3 ? h2 = 9 : /[>=`]/.test(e3) ? P2() : "<" === e3 ? O2() : h2 = 10);
  }
  function E2(e3) {
    '"' === e3 && (h2 = 11);
  }
  function k2(e3) {
    "'" === e3 && (h2 = 11);
  }
  function x2(e3) {
    dt.test(e3) ? h2 = 4 : ">" === e3 ? j2() : "<" === e3 && O2();
  }
  function I2(e3) {
    dt.test(e3) ? h2 = 4 : "/" === e3 ? h2 = 12 : ">" === e3 ? j2() : "<" === e3 ? O2() : (h2 = 4, c2--);
  }
  function T2(e3) {
    ">" === e3 ? (p2 = new Gt(st(st({}, p2), { isClosing: true })), j2()) : h2 = 4;
  }
  function D2(t3) {
    "--" === e2.substr(c2, 2) ? (c2 += 2, p2 = new Gt(st(st({}, p2), { type: "comment" })), h2 = 14) : "DOCTYPE" === e2.substr(c2, 7).toUpperCase() ? (c2 += 7, p2 = new Gt(st(st({}, p2), { type: "doctype" })), h2 = 20) : P2();
  }
  function S2(e3) {
    "-" === e3 ? h2 = 15 : ">" === e3 ? P2() : h2 = 16;
  }
  function M2(e3) {
    "-" === e3 ? h2 = 18 : ">" === e3 ? P2() : h2 = 16;
  }
  function F2(e3) {
    "-" === e3 && (h2 = 17);
  }
  function B2(e3) {
    h2 = "-" === e3 ? 18 : 16;
  }
  function R2(e3) {
    ">" === e3 ? j2() : "!" === e3 ? h2 = 19 : "-" === e3 || (h2 = 16);
  }
  function N2(e3) {
    "-" === e3 ? h2 = 17 : ">" === e3 ? j2() : h2 = 16;
  }
  function _2(e3) {
    ">" === e3 ? j2() : "<" === e3 && O2();
  }
  function P2() {
    h2 = 0, p2 = u2;
  }
  function O2() {
    h2 = 1, p2 = new Gt({ idx: c2 });
  }
  function j2() {
    var t3 = e2.slice(d2, p2.idx);
    t3 && i2(t3, d2), "comment" === p2.type ? a2(p2.idx) : "doctype" === p2.type ? o2(p2.idx) : (p2.isOpening && n2(p2.name, p2.idx), p2.isClosing && r2(p2.name, p2.idx)), P2(), d2 = c2 + 1;
  }
  function U2() {
    var t3 = p2.idx + (p2.isClosing ? 2 : 1);
    return e2.slice(t3, c2).toLowerCase();
  }
  d2 < c2 && (s2 = e2.slice(d2, c2), i2(s2, d2), d2 = c2 + 1);
}
var Gt = function(e2) {
  void 0 === e2 && (e2 = {}), this.idx = void 0 !== e2.idx ? e2.idx : -1, this.type = e2.type || "tag", this.name = e2.name || "", this.isOpening = !!e2.isOpening, this.isClosing = !!e2.isClosing;
}, zt = function() {
  function e2(t2) {
    void 0 === t2 && (t2 = {}), this.version = e2.version, this.urls = {}, this.email = true, this.phone = true, this.hashtag = false, this.mention = false, this.newWindow = true, this.stripPrefix = { scheme: true, www: true }, this.stripTrailingSlash = true, this.decodePercentEncoding = true, this.truncate = { length: 0, location: "end" }, this.className = "", this.replaceFn = null, this.context = void 0, this.sanitizeHtml = false, this.matchers = null, this.tagBuilder = null, this.urls = this.normalizeUrlsCfg(t2.urls), this.email = "boolean" == typeof t2.email ? t2.email : this.email, this.phone = "boolean" == typeof t2.phone ? t2.phone : this.phone, this.hashtag = t2.hashtag || this.hashtag, this.mention = t2.mention || this.mention, this.newWindow = "boolean" == typeof t2.newWindow ? t2.newWindow : this.newWindow, this.stripPrefix = this.normalizeStripPrefixCfg(t2.stripPrefix), this.stripTrailingSlash = "boolean" == typeof t2.stripTrailingSlash ? t2.stripTrailingSlash : this.stripTrailingSlash, this.decodePercentEncoding = "boolean" == typeof t2.decodePercentEncoding ? t2.decodePercentEncoding : this.decodePercentEncoding, this.sanitizeHtml = t2.sanitizeHtml || false;
    var s2 = this.mention;
    if (false !== s2 && "twitter" !== s2 && "instagram" !== s2 && "soundcloud" !== s2) throw new Error("invalid `mention` cfg - see docs");
    var n2 = this.hashtag;
    if (false !== n2 && "twitter" !== n2 && "facebook" !== n2 && "instagram" !== n2) throw new Error("invalid `hashtag` cfg - see docs");
    this.truncate = this.normalizeTruncateCfg(t2.truncate), this.className = t2.className || this.className, this.replaceFn = t2.replaceFn || this.replaceFn, this.context = t2.context || this;
  }
  return e2.link = function(t2, s2) {
    return new e2(s2).link(t2);
  }, e2.parse = function(t2, s2) {
    return new e2(s2).parse(t2);
  }, e2.prototype.normalizeUrlsCfg = function(e3) {
    return null == e3 && (e3 = true), "boolean" == typeof e3 ? { schemeMatches: e3, wwwMatches: e3, tldMatches: e3 } : { schemeMatches: "boolean" != typeof e3.schemeMatches || e3.schemeMatches, wwwMatches: "boolean" != typeof e3.wwwMatches || e3.wwwMatches, tldMatches: "boolean" != typeof e3.tldMatches || e3.tldMatches };
  }, e2.prototype.normalizeStripPrefixCfg = function(e3) {
    return null == e3 && (e3 = true), "boolean" == typeof e3 ? { scheme: e3, www: e3 } : { scheme: "boolean" != typeof e3.scheme || e3.scheme, www: "boolean" != typeof e3.www || e3.www };
  }, e2.prototype.normalizeTruncateCfg = function(e3) {
    return "number" == typeof e3 ? { length: e3, location: "end" } : function(e4, t2) {
      for (var s2 in t2) t2.hasOwnProperty(s2) && void 0 === e4[s2] && (e4[s2] = t2[s2]);
      return e4;
    }(e3 || {}, { length: Number.POSITIVE_INFINITY, location: "end" });
  }, e2.prototype.parse = function(e3) {
    var t2 = this, s2 = ["a", "style", "script"], n2 = 0, r2 = [];
    return Lt(e3, { onOpenTag: function(e4) {
      s2.indexOf(e4) >= 0 && n2++;
    }, onText: function(e4, s3) {
      if (0 === n2) {
        var i2 = function(e5, t3) {
          if (!t3.global) throw new Error("`splitRegex` must have the 'g' flag set");
          for (var s4, n3 = [], r3 = 0; s4 = t3.exec(e5); ) n3.push(e5.substring(r3, s4.index)), n3.push(s4[0]), r3 = s4.index + s4[0].length;
          return n3.push(e5.substring(r3)), n3;
        }(e4, /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi), a2 = s3;
        i2.forEach(function(e5, s4) {
          if (s4 % 2 == 0) {
            var n3 = t2.parseText(e5, a2);
            r2.push.apply(r2, n3);
          }
          a2 += e5.length;
        });
      }
    }, onCloseTag: function(e4) {
      s2.indexOf(e4) >= 0 && (n2 = Math.max(n2 - 1, 0));
    }, onComment: function(e4) {
    }, onDoctype: function(e4) {
    } }), r2 = this.compactMatches(r2), r2 = this.removeUnwantedMatches(r2);
  }, e2.prototype.compactMatches = function(e3) {
    e3.sort(function(e4, t3) {
      return e4.getOffset() - t3.getOffset();
    });
    for (var t2 = 0; t2 < e3.length - 1; t2++) {
      var s2 = e3[t2], n2 = s2.getOffset(), r2 = s2.getMatchedText().length, i2 = n2 + r2;
      if (t2 + 1 < e3.length) {
        if (e3[t2 + 1].getOffset() === n2) {
          var a2 = e3[t2 + 1].getMatchedText().length > r2 ? t2 : t2 + 1;
          e3.splice(a2, 1);
          continue;
        }
        e3[t2 + 1].getOffset() < i2 && e3.splice(t2 + 1, 1);
      }
    }
    return e3;
  }, e2.prototype.removeUnwantedMatches = function(e3) {
    return this.hashtag || Ye(e3, function(e4) {
      return "hashtag" === e4.getType();
    }), this.email || Ye(e3, function(e4) {
      return "email" === e4.getType();
    }), this.phone || Ye(e3, function(e4) {
      return "phone" === e4.getType();
    }), this.mention || Ye(e3, function(e4) {
      return "mention" === e4.getType();
    }), this.urls.schemeMatches || Ye(e3, function(e4) {
      return "url" === e4.getType() && "scheme" === e4.getUrlMatchType();
    }), this.urls.wwwMatches || Ye(e3, function(e4) {
      return "url" === e4.getType() && "www" === e4.getUrlMatchType();
    }), this.urls.tldMatches || Ye(e3, function(e4) {
      return "url" === e4.getType() && "tld" === e4.getUrlMatchType();
    }), e3;
  }, e2.prototype.parseText = function(e3, t2) {
    void 0 === t2 && (t2 = 0), t2 = t2 || 0;
    for (var s2 = this.getMatchers(), n2 = [], r2 = 0, i2 = s2.length; r2 < i2; r2++) {
      for (var a2 = s2[r2].parseMatches(e3), o2 = 0, u2 = a2.length; o2 < u2; o2++) a2[o2].setOffset(t2 + a2[o2].getOffset());
      n2.push.apply(n2, a2);
    }
    return n2;
  }, e2.prototype.link = function(e3) {
    if (!e3) return "";
    this.sanitizeHtml && (e3 = e3.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    for (var t2 = this.parse(e3), s2 = [], n2 = 0, r2 = 0, i2 = t2.length; r2 < i2; r2++) {
      var a2 = t2[r2];
      s2.push(e3.substring(n2, a2.getOffset())), s2.push(this.createMatchReturnVal(a2)), n2 = a2.getOffset() + a2.getMatchedText().length;
    }
    return s2.push(e3.substring(n2)), s2.join("");
  }, e2.prototype.createMatchReturnVal = function(e3) {
    var t2;
    return this.replaceFn && (t2 = this.replaceFn.call(this.context, e3)), "string" == typeof t2 ? t2 : false === t2 ? e3.getMatchedText() : t2 instanceof Ve ? t2.toAnchorString() : e3.buildTag().toAnchorString();
  }, e2.prototype.getMatchers = function() {
    if (this.matchers) return this.matchers;
    var e3 = this.getTagBuilder(), t2 = [new Pt({ tagBuilder: e3, serviceName: this.hashtag }), new Dt({ tagBuilder: e3 }), new jt({ tagBuilder: e3 }), new Ht({ tagBuilder: e3, serviceName: this.mention }), new Rt({ tagBuilder: e3, stripPrefix: this.stripPrefix, stripTrailingSlash: this.stripTrailingSlash, decodePercentEncoding: this.decodePercentEncoding })];
    return this.matchers = t2;
  }, e2.prototype.getTagBuilder = function() {
    var e3 = this.tagBuilder;
    return e3 || (e3 = this.tagBuilder = new Ze({ newWindow: this.newWindow, truncate: this.truncate, className: this.className })), e3;
  }, e2.version = "3.14.3", e2.AnchorTagBuilder = Ze, e2.HtmlTag = Ve, e2.matcher = { Email: Dt, Hashtag: Pt, Matcher: ut, Mention: Ht, Phone: jt, Url: Rt }, e2.match = { Email: nt, Hashtag: rt, Match: Ke, Mention: it, Phone: at, Url: ot }, e2;
}();
function Jt(e2, t2 = e2) {
  return { type: "autolink", url: e2, text: t2 };
}
const Yt = Ue(/<!!mention:([^>\s]*?)\|(.*?)>/gm, ([e2, t2, s2]) => /* @__PURE__ */ function(e3, t3) {
  return { type: "mention", id: e3, text: t3 };
}(decodeURIComponent(t2), s2)), Qt = Ue(/<!!customemoji:(.*?)>/gm, ([e2, t2]) => /* @__PURE__ */ function(e3) {
  return { type: "customemoji", text: e3 };
}(t2)), Vt = Ue(/<((?:https?|mailto):.*?)\|(.*?)>/gi, ([e2, t2, s2]) => /* @__PURE__ */ function(e3, t3 = []) {
  return { type: "link", url: e3, children: t3 };
}(t2, [s2])), Zt = Ue(/<actionlink:([^|]+)[|]([^>]*)>/gi, ([e2, t2, s2]) => {
  const { action: n2, params: r2 } = Xt(t2);
  return /* @__PURE__ */ function(e3, t3, s3 = []) {
    return { type: "actionlink", action: e3, params: t3, children: s3 };
  }(n2, r2, [s2]);
}), Kt = Ue(/<actionbutton:([^|]+)[|]([^>]*)>/gi, ([e2, t2, s2]) => {
  const { action: n2, params: r2 } = Xt(t2);
  return /* @__PURE__ */ function(e3, t3, s3 = []) {
    return { type: "actionbutton", action: e3, params: t3, children: s3 };
  }(n2, r2, [s2]);
});
function Xt(e2) {
  const t2 = e2.indexOf("?");
  if (-1 === t2) return { action: e2, params: {} };
  return { action: e2.slice(0, t2), params: Object.fromEntries(new URLSearchParams(e2.slice(t2))) };
}
const es = Ue(/(?:^|\n)(?:\s*[-*+]\s+[^\n]+(?:\n|$))+/g, ([e2]) => /* @__PURE__ */ function(e3 = []) {
  return { type: "bulletlist", children: e3 };
}([e2.startsWith("\n") ? e2.slice(1) : e2])), ts = Ue(/^\s*[-*+]\s+([^\n]+)(?:\n|$)/gm, ([e2, t2]) => ({ type: "bulletpoint", children: [t2] })), ss = (e2) => {
  const t2 = /(?:^|[^-:/\w])([(+]?[0-9](?:[-_+ ().]?[0-9]){5,11}[0-9])(?:[^-:/\w]|$)/g;
  let s2 = 0;
  const n2 = [];
  for (const r2 of V(e2, t2)) {
    const t3 = r2[0], i2 = r2[1], a2 = t3.startsWith(i2) ? r2.index : r2.index + 1;
    a2 - s2 > 0 && n2.push(e2.substring(s2, a2));
    const o2 = Jt("tel:" + i2.replace(/[^0-9+]/g, ""), i2);
    n2.push(o2), s2 = a2 + i2.length;
  }
  return s2 < e2.length && n2.push(e2.substring(s2)), n2;
}, ns = (e2) => Vt(e2).flatMap((e3) => "string" == typeof e3 ? rs(e3) : ["<", ...rs(e3.url), ...rs("|" + e3.children[0] + ">")]), rs = (e2) => {
  const t2 = zt.parse(e2, { urls: true, email: true, phone: false, hashtag: false, mention: false }), s2 = [];
  let n2 = 0;
  for (const r2 of t2) {
    const t3 = r2.getOffset(), i2 = r2.getMatchedText(), a2 = i2.length;
    let o2 = i2;
    r2 instanceof nt ? o2 = "mailto:" + r2.getEmail() : r2 instanceof ot && (o2 = r2.getUrl()), t3 > n2 && s2.push(e2.substring(n2, t3)), s2.push(Jt(o2, i2)), n2 = t3 + a2;
  }
  return n2 < e2.length && s2.push(e2.substring(n2)), s2;
}, is = ["Codeblock", "Codespan", "FormattedLink", "Wikitext", "Autolink", "Actions", "Mention", "Mention", "BulletPoint", "CustomEmoji"];
function as(e2 = { except: [] }) {
  var _a2;
  const t2 = { multilineSteps: [], singlelineSteps: [] }, s2 = (_a2 = e2.except) != null ? _a2 : is.filter((t3) => !e2.only.includes(t3));
  return s2.includes("BulletPoint") || t2.multilineSteps.push(es, ts), s2.includes("Mention") || t2.singlelineSteps.push(Yt), s2.includes("CustomEmoji") || t2.singlelineSteps.push(Qt), s2.includes("Codespan") || t2.multilineSteps.push(Ue(/```([^]+?)```/g, ([e3, t3]) => ({ type: "codespan", text: t3.replace(/<!!mention:.*?\|([^>]*)>/gim, "@$1").replace(/<!!customemoji:(.*?)>/gim, "$1") }))), s2.includes("FormattedLink") || t2.singlelineSteps.push(Vt), s2.includes("Actions") || (t2.singlelineSteps.push(Zt), t2.singlelineSteps.push(Kt)), s2.includes("Wikitext") || t2.singlelineSteps.push(Le), s2.includes("Autolink") || t2.singlelineSteps.push(ns, ss), t2;
}
const os = function(e2) {
  const t2 = RegExp(`[^${e2}]+${e2}?|${e2}`, "g");
  return (e3) => Array.from(e3.match(t2) || []);
}("\n");
function us(e2, t2 = { except: [] }) {
  let s2 = function(e3, t3) {
    let s3 = [e3];
    return s3 = ls(s3, t3.multilineSteps), s3 = ls(s3, [os]), s3 = ls(s3, t3.singlelineSteps), s3 = hs(s3), s3;
  }(e2, as(t2));
  return s2 = ds(s2, false), s2;
}
function cs(e2) {
  return us(e2, { except: ["FormattedLink", "Actions"] });
}
function ls(e2, t2) {
  return t2.reduce((e3, t3) => je(e3, t3), e2);
}
function hs(e2) {
  const t2 = [];
  let s2 = -1;
  for (const n2 of e2) "string" == typeof n2 ? "string" == typeof t2[s2] ? t2[s2] += n2 : t2[++s2] = n2 : t2[++s2] = "children" in n2 ? __spreadProps(__spreadValues({}, n2), { children: hs(n2.children) }) : n2;
  return t2;
}
function ds(e2, t2) {
  const s2 = [];
  let n2 = [];
  for (let r2 = 0; r2 < e2.length; r2++) {
    const i2 = e2[r2];
    if ("string" == typeof i2) n2.push(i2);
    else if ("children" in i2) {
      n2.length > 0 && (s2.push(n2.join("")), n2 = []);
      const e3 = ds(i2.children, t2 || "link" === i2.type || "actionbutton" === i2.type || "actionlink" === i2.type);
      s2.push(__spreadProps(__spreadValues({}, i2), { children: e3 }));
    } else "autolink" === i2.type && t2 ? n2.push(i2.text) : (n2.length > 0 && (s2.push(n2.join("")), n2 = []), s2.push(i2));
  }
  return n2.length > 0 && (s2.push(n2.join("")), n2 = []), s2;
}
class ps {
  constructor(e2, t2, s2, n2) {
    this.emoji = e2, this.messageId = t2, this.conversationId = s2, this._realtimeClient = n2;
  }
  get brandedMessageId() {
    return this.messageId;
  }
  get brandedConversationId() {
    return this.conversationId;
  }
  add() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("PUT", ["conversations", this.brandedConversationId, "messages", this.brandedMessageId, "reactions", this.emoji, this._realtimeClient.userId], {});
      e(`Add ${this.emoji} reaction on message ${this.messageId} in conversation ${this.conversationId}`, t2);
    });
  }
  remove() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("DELETE", ["conversations", this.brandedConversationId, "messages", this.brandedMessageId, "reactions", this.emoji, this._realtimeClient.userId], {});
      (t2.ok || "server" !== t2.where || 404 !== t2.value.status) && e(`Remove ${this.emoji} reaction from message ${this.messageId} in conversation ${this.conversationId}`, t2);
    });
  }
}
class fs {
  constructor(e2, t2, s2) {
    this.id = e2, this.conversationId = t2, this._realtimeClient = s2;
  }
  get brandedId() {
    return this.id;
  }
  get brandedConversationId() {
    return this.conversationId;
  }
  reaction(e2) {
    if ("string" != typeof e2) throw new Error(`Creating ReactionRef failed because emoji "${e2}" is not a string`);
    if ("" === e2) throw new Error(`Creating ReactionRef failed because emoji "${e2}" is an empty string`);
    return new ps(e2, this.brandedId, this.brandedConversationId, this._realtimeClient);
  }
  get() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("GET", ["me", "conversations", this.brandedConversationId, "messages", this.brandedId], {});
      if (!t2.ok && "server" === t2.where && 404 === t2.value.status) return null;
      if (!t2.ok && "server" === t2.where && 403 === t2.value.status && "NOT_A_PARTICIPANT" === t2.value.errorCode) return null;
      const s2 = e("Get message " + this.id, t2), n2 = yield this._realtimeClient.hydrateMessageData(s2, this.brandedConversationId);
      return Ne("Get message " + this.id, n2);
    });
  }
  edit(t2) {
    return __async(this, null, function* () {
      const s2 = { content: ms(t2), custom: "string" == typeof t2 ? void 0 : t2.custom }, n2 = yield this._realtimeClient.call("PATCH", ["conversations", this.brandedConversationId, "messages", this.brandedId], s2);
      e(`Edit message ${this.id} in conversation ${this.conversationId}`, n2);
    });
  }
  delete() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("DELETE", ["conversations", this.brandedConversationId, "messages", this.brandedId], {});
      (t2.ok || "server" !== t2.where || 404 !== t2.value.status) && e(`Delete message ${this.id} in conversation ${this.conversationId}`, t2);
    });
  }
}
function ms(e2) {
  if ("string" == typeof e2) {
    return [{ type: "text", children: us(e2) }];
  }
  if ("text" in e2 && e2.text) {
    return [{ type: "text", children: us(e2.text) }];
  }
  if ("content" in e2 && e2.content) return e2.content;
}
class gs {
  constructor(e2, t2) {
    this.id = e2, this._realtimeClient = t2, this.uselessObjForTypeCheck = { subject: null, photoUrl: null, welcomeMessages: null, custom: null, access: null, notify: null };
  }
  get brandedId() {
    return this.id;
  }
  get brandedUserId() {
    return this._realtimeClient.userId;
  }
  participant(e2) {
    if ("string" == typeof e2) {
      if ("" === e2) throw new Error(`Creating ParticipantRef failed because ID "${e2}" is an empty string`);
      return new Pe(e2, this.id, this._realtimeClient);
    }
    if ("brandedId" in e2) return new Pe(e2.id, this.id, this._realtimeClient);
    throw new Error(`Creating ParticipantRef failed because user "${e2}" is not a string or a UserRef`);
  }
  message(e2) {
    if ("string" != typeof e2) throw new Error(`Creating MessageRef failed because ID "${e2}" is not a string`);
    if ("" === e2) throw new Error(`Creating MessageRef failed because ID "${e2}" is an empty string`);
    return new fs(e2, this.brandedId, this._realtimeClient);
  }
  get() {
    return __async(this, null, function* () {
      const t2 = this._realtimeClient.listMessages(this.brandedId, { limit: 1 }), s2 = yield this._realtimeClient.call("GET", ["me", "conversations", this.brandedId], {});
      if (!s2.ok && "server" === s2.where && 404 === s2.value.status) return null;
      const n2 = e("Get conversation " + this.id, s2), r2 = Ne("Get last message in conversation " + this.id, yield t2);
      return function(e2, t3) {
        return _({ id: e2.id, subject: e2.subject, photoUrl: e2.photoUrl, welcomeMessages: _(e2.welcomeMessages), custom: _(e2.custom), createdAt: e2.createdAt, joinedAt: e2.joinedAt, lastMessageAt: e2.lastMessageAt, unreadMessageCount: e2.unreadMessageCount, isUnread: e2.isUnread, access: e2.access, notify: e2.notify, lastMessage: t3, readUntil: e2.readUntil, everyoneReadUntil: e2.everyoneReadUntil });
      }(n2, 0 === r2.length ? null : r2[0]);
    });
  }
  set(t2) {
    return __async(this, null, function* () {
      const s2 = this._realtimeClient.call("PUT", ["conversations", this.brandedId], t2), n2 = this._realtimeClient.call("PUT", ["conversations", this.brandedId, "participants", this.brandedUserId], t2), r2 = yield s2;
      !r2.ok && "server" === r2.where && 403 === r2.value.status && "UNAUTHORIZED_TO_EDIT" === r2.value.errorCode && function(e2) {
        if (void 0 !== e2.subject) return false;
        if (void 0 !== e2.photoUrl) return false;
        if (void 0 !== e2.welcomeMessages) return false;
        if (null === e2.custom) return false;
        if (void 0 !== e2.custom && Object.values(e2.custom).some((e3) => void 0 !== e3)) return false;
        return true;
      }(t2) || e("Set conversation " + this.id, r2);
      const i2 = yield n2;
      !i2.ok && "server" === i2.where && 403 === i2.value.status && "UNAUTHORIZED_TO_EDIT_PARTICIPANT" === i2.value.errorCode && function(e2) {
        return void 0 === e2.access && void 0 === e2.notify;
      }(t2) || e("Set your participation in conversation " + this.id, i2);
    });
  }
  createIfNotExists() {
    return __async(this, arguments, function* (t2 = {}) {
      const s2 = this._realtimeClient.call("POST", ["conversations", this.brandedId], t2), n2 = this._realtimeClient.call("POST", ["conversations", this.brandedId, "participants", this.brandedUserId], t2), r2 = yield s2;
      (r2.ok || "server" !== r2.where || 409 !== r2.value.status) && e("Create conversation " + this.id, yield s2);
      const i2 = yield n2;
      (i2.ok || "server" !== i2.where || 409 !== i2.value.status) && e("Join conversation " + this.id, yield n2);
    });
  }
  markAsRead() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("POST", ["me", "conversations", this.brandedId, "read"], {});
      e(`Mark ${this.id} as read`, t2);
    });
  }
  markAsUnread() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("POST", ["me", "conversations", this.brandedId, "unread"], {});
      e(`Mark ${this.id} as unread`, t2);
    });
  }
  send(t2) {
    return __async(this, null, function* () {
      const s2 = { content: vs(t2), referencedMessageId: ws(t2), custom: "string" == typeof t2 ? void 0 : t2.custom, idempotencyKey: Oe((/* @__PURE__ */ new Date()).getTime()) }, n2 = yield this._realtimeClient.call("POST", ["conversations", this.brandedId, "messages"], s2), r2 = e("Send message to conversation " + this.id, n2);
      return new fs(r2.id, this.brandedId, this._realtimeClient);
    });
  }
  subscribeMessages(e2) {
    return this._realtimeClient.subscribe(["me", "conversations", this.brandedId, "messages"], e2);
  }
  subscribeParticipants(e2) {
    return this._realtimeClient.subscribe(["me", "conversations", this.brandedId, "participants"], e2);
  }
  subscribe(e2) {
    return this._realtimeClient.subscribe(["me", "conversations", this.brandedId], e2);
  }
  subscribeTyping(e2) {
    return this._realtimeClient.subscribe(["me", "conversations", this.brandedId, "typing"], e2);
  }
  markAsTyping() {
    return __async(this, null, function* () {
      const t2 = yield this._realtimeClient.call("POST", ["me", "conversations", this.brandedId, "typing"], {});
      e(`Set user as typing in  ${this.id}`, t2);
    });
  }
}
function vs(e2) {
  if ("string" == typeof e2) {
    return [{ type: "text", children: cs(e2) }];
  }
  if ("text" in e2) {
    return [{ type: "text", children: cs(e2.text) }];
  }
  return e2.content;
}
function ws(e2) {
  if ("string" == typeof e2) return;
  const t2 = e2.referencedMessage;
  return void 0 !== t2 ? "string" == typeof t2 ? t2 : t2.id : void 0;
}
class bs {
  constructor(e2, t2, s2) {
    this.realtimeWsApiUrl = e2, this.internalHttpApiUrl = t2, this.restApiHttpUrl = s2;
  }
  getBokensUrl(e2, t2, s2) {
    return this.internalHttpApiUrl + `/${e2}/bokens/${encodeURIComponent(t2)}?signature=${encodeURIComponent(s2 != null ? s2 : "")}`;
  }
  getRealtimeWsUrl(e2, t2, s2, n2, r2) {
    const i2 = encodeURIComponent(t2);
    return this.realtimeWsApiUrl + `/${e2}/realtime/${i2}?talkjs-client-build=${r2 != null ? r2 : "standalone"}&talkjs-core=${s2}&talkjs-client-id=${n2}`;
  }
  static fromHost(e2) {
    var _a2;
    const t2 = new bs("wss://realtime.talkjs.com/v1", "https://app.talkjs.com/api/v0", "https://api.talkjs.com/v1");
    if (!e2) return t2;
    if ("@currentHost" === e2) {
      if ("undefined" == typeof location) throw new Error("You can only use @currentHost in a browser.");
      e2 = ((_a2 = window.top) != null ? _a2 : window).location.host;
    }
    if (e2.endsWith("talkjs.com")) {
      const s2 = e2.match(/^(?:\w+-)?([^.]+)\.talkjs\.com$/);
      if (s2) {
        const e3 = s2[1];
        return ["app", "cdn", "api", "realtime"].includes(e3) ? t2 : new bs(`wss://realtime-${e3}.talkjs.com/v1`, `https://app-${e3}.talkjs.com/api/v0`, `https://api-${e3}.talkjs.com/v1`);
      }
      return t2;
    }
    return e2.includes("localhost") || e2.includes("localtest.me") || /^\d+\.\d+\.\d+\.\d+(:\d+)?$/.test(e2) ? new bs(`ws://${e2}/public_api/v1`, `http://${e2}/api/v0`, `http://${e2}/public_api/v1`) : new bs(`wss://${e2}/public_api/v1`, `https://${e2}/api/v0`, `https://${e2}/public_api/v1`);
  }
}
function ys({ method: e2, url: t2, data: s2, options: n2, attempts: r2, shouldRetry: i2, authProvider: o2 }) {
  var _a2;
  (!r2 || r2 <= 0) && (r2 = 1);
  const u2 = { "x-talkjs-client-build": "jssdk-dev", "x-talkjs-client-date": "2025-10-30T09:02:16.772Z" };
  s2 instanceof FormData || (u2["Content-Type"] = (_a2 = n2 == null ? void 0 : n2.contentType) != null ? _a2 : "application/json");
  return a(r2, () => __async(this, null, function* () {
    if (o2) {
      const e3 = yield o2.getToken();
      u2.Authorization = `Bearer ${e3}`;
    }
    return fetch(t2, { method: e2, headers: u2, body: s2 }).then((e3) => {
      if (e3.ok) return e3;
      throw e3;
    });
  }), { initialDelay: 0.2, log: void 0, shouldRetry: (s3) => __async(this, null, function* () {
    return o2 && 401 === s3.status ? (Ds.log(`401 error from ${e2} ${t2}, ${yield o2.getToken()}`), o2.refreshToken(), true) : i2 ? i2(s3) : !("status" in s3 && s3.status >= 400 && s3.status < 500);
  }) }).catch((s3) => {
    if (Math.random() < 0.1 && !t2.toString().startsWith("https://capture.trackjs.com")) {
      const n3 = `Network Error for ${e2} ${t2}`;
      if ("undefined" != typeof window) if (s3 instanceof Response) {
        s3.clone().text().then((e3) => Ds.log(`${n3} ${s3.status} ${e3} (10% logged)`));
      } else Ds.log(`${n3} ${s3} (10% logged)`);
      console.error("[TalkJS]", n3);
    }
    throw s3;
  });
}
const { cdnHost: Cs, appHost: As, restHost: Es, realtimeHost: ks, appProtocol: xs, appWsProtocol: Is } = function() {
  if ("undefined" == typeof window) return { cdnHost: "test-hostname", appHost: "test-hostname", appProtocol: "http:", appWsProtocol: "ws:" };
  if (!globalThis.document) return { appHost: "app.talkjs.com", appProtocol: "http:", appWsProtocol: "ws:" };
  const e2 = function() {
    if (document.currentScript) return document.currentScript.src;
    try {
      throw new Error();
    } catch (e3) {
      const t3 = e3.stack.match(/https?:\/\/.*\.(js|jsx|ts|tsx)/);
      return t3 ? t3[0] : "";
    }
  }(), t2 = new URL(e2), s2 = t2.host, n2 = function(e3) {
    if (e3.match(/^cdn[.-]/)) return e3.replace(/^cdn/, "app");
    if ("talkjs.com" === e3) return "app.talkjs.com";
    return e3;
  }(s2), r2 = function(e3) {
    if (e3.match(/^app[.-]/)) return e3.replace(/^app/, "api");
    return e3 + "/public_api";
  }(n2), i2 = function(e3) {
    if (e3.match(/^app[.-]/)) return e3.replace(/^app/, "realtime");
    return e3 + "/public_api";
  }(n2), a2 = t2.protocol;
  return { cdnHost: s2, appHost: n2, restHost: r2, realtimeHost: i2, appProtocol: a2, appWsProtocol: "https:" === a2 ? "wss:" : "ws:" };
}();
const Ts = As.startsWith("app.talkjs.com");
const Ds = "undefined" == typeof window ? { log: (e2) => Promise.resolve(), setData: (e2) => {
} } : new (_b = class {
  constructor(e2) {
    __privateAdd(this, _e2);
    __privateAdd(this, _t2);
    var _a2, _b2, _c, _d;
    this._timeCreated = Date.now(), this._enabled = Ts, __privateSet(this, _e2, (_b2 = (_a2 = globalThis.document) == null ? void 0 : _a2.referrer) != null ? _b2 : ""), __privateSet(this, _t2, ((_d = (_c = globalThis.location) == null ? void 0 : _c.href) != null ? _d : globalThis.HermesInternal) ? "React Native Hermes" : ""), this._trackJSData = { customer: { application: "", correlationId: "", sessionId: "", token: "", userId: "", version: "dev-2025-10-30T09:02:16.772Z" }, entry: "direct", environment: { age: Date.now() - this._timeCreated, dependencies: {}, originalUrl: __privateGet(this, _t2), referrer: __privateGet(this, _e2), userAgent: window.navigator.userAgent }, metadata: [], nav: [], network: [], url: __privateGet(this, _t2), stack: "", timestamp: (/* @__PURE__ */ new Date()).toISOString(), version: "dev-2025-10-30T09:02:16.772Z", throttled: 0 }, this._url = `https://capture.trackjs.com/capture?token=${e2}`, this._trackJSData.customer.token = e2;
  }
  setData({ appId: e2, meId: t2, sessionId: s2 }) {
    this._trackJSData.customer.userId = e2, this._trackJSData.customer.sessionId = `${e2}/${t2}`, this._trackJSData.customer.correlationId = s2;
  }
  log(e2) {
    return __async(this, null, function* () {
      try {
        if (!this._enabled) return Promise.resolve();
        const t2 = __spreadProps(__spreadValues({}, this._trackJSData), { message: e2 });
        yield ys({ method: "POST", url: this._url, data: JSON.stringify(t2), options: { contentType: "text/plain" } });
      } catch (e3) {
        console.error("[TalkJS] Failed when sending an error report. Error: ", e3);
      }
    });
  }
}, _e2 = new WeakMap(), _t2 = new WeakMap(), _b)("970cd0be0fb74630b75c8451051299dc");
class Ss {
  constructor(e2, t2 = {}) {
    this._onSubscription = t2, this._handlers = {};
    for (const t3 in e2) Object.hasOwnProperty.call(e2, t3) && (this._handlers[t3] = []);
  }
  emit(e2, t2) {
    for (const s2 of this._handlers[e2]) try {
      s2(t2);
    } catch (t3) {
      console.error(`[TalkJS] '${String(e2)}' handler threw an error:`, t3);
    }
  }
  emitAsync(e2, t2) {
    return __async(this, null, function* () {
      try {
        const s2 = this._handlers[e2].map((e3) => e3(t2));
        yield Promise.all(s2);
      } catch (t3) {
        console.error(`[TalkJS] '${String(e2)}' handler threw an error:`, t3);
      }
    });
  }
  supports(e2) {
    return e2 in this._handlers;
  }
  on(e2, t2) {
    var _a2, _b2;
    if (!this.supports(e2)) throw new Error(`Unknown event type '${String(e2)}'`);
    (_b2 = (_a2 = this._onSubscription)[e2]) == null ? void 0 : _b2.call(_a2), this._handlers[e2].push(t2);
  }
  off(e2, t2) {
    if (!Object.hasOwnProperty.call(this._handlers, e2)) throw new Error(`Unknown event type '${String(e2)}'`);
    const s2 = this._handlers[e2].indexOf(t2);
    -1 !== s2 && this._handlers[e2].splice(s2, 1);
  }
  removeAllListeners() {
    for (const e2 in this._handlers) this._handlers[e2] = [];
  }
  handles(e2) {
    return this._handlers[e2].length > 0;
  }
  subscribe(e2, t2) {
    return this.on(e2, t2), { unsubscribe: () => this.off(e2, t2) };
  }
}
class Ms {
  constructor(e2, t2, s2, n2, r2, i2) {
    if (this.appId = t2, this.userId = s2, this.tokenFetcher = r2, this.usingBokens = false, this.requestInProgress = false, this.eventEmitter = new Ss({ tokenChanged(e3) {
    }, tokenRefreshFailed(e3) {
    }, tokenAccepted(e3) {
    } }), this.sessionExpiryWarningTimeoutId = void 0, i2 && (n2 || r2)) throw new Error("[TalkJS] If providing a signature for authentication, you must not provide a token or tokenFetcher.");
    n2 ? this.fetchToken(() => n2) : (r2 || (this.usingBokens = true, this.tokenFetcher = () => this.sendBokenRequest(e2, i2)), this.refreshToken());
  }
  get canRefreshToken() {
    return this.usingBokens || !!this.tokenFetcher;
  }
  getToken() {
    return this.token;
  }
  refreshToken() {
    if (!this.requestInProgress) {
      if (!this.tokenFetcher) throw this.emitTokenRefreshFailed("no `tokenFetcher` provided"), new Error("[TalkJS] Cannot refresh token, no `tokenFetcher` provided.");
      this.fetchToken(this.tokenFetcher);
    }
  }
  onTokenChanged(e2) {
    return this.eventEmitter.on("tokenChanged", e2), () => {
      this.eventEmitter.off("tokenChanged", e2);
    };
  }
  emitTokenChanged(e2) {
    this.eventEmitter.emit("tokenChanged", e2);
  }
  onTokenRefreshFailed(e2) {
    return this.eventEmitter.on("tokenRefreshFailed", e2), () => {
      this.eventEmitter.off("tokenRefreshFailed", e2);
    };
  }
  emitTokenRefreshFailed(e2) {
    this.eventEmitter.emit("tokenRefreshFailed", e2), console.error(`[TalkJS] Could not authenticate, cannot recover automatically: ${e2}`);
  }
  onTokenAccepted(e2) {
    return this.eventEmitter.on("tokenAccepted", e2), () => {
      this.eventEmitter.off("tokenAccepted", e2);
    };
  }
  emitTokenAccepted(e2) {
    this.eventEmitter.emit("tokenAccepted", e2);
  }
  clearScheduledRefresh() {
    this.sessionExpiryWarningTimeoutId && clearTimeout(this.sessionExpiryWarningTimeoutId);
  }
  scheduleRefresh(e2) {
    if (this.clearScheduledRefresh(), null === e2) return;
    const t2 = void 0 !== this.tokenFetcher;
    e2 < 120 && !t2 ? console.warn(`[TalkJS] TalkJS will stop working in ${e2} seconds due to auth token expiry. Token expires in ${e2} seconds, and cannot be refreshed because no \`tokenFetcher\` was provided when creating the session. Non-refreshable tokens are recommended to expire at least 24 hours in the future.`) : e2 < 120 && t2 ? console.warn(`[TalkJS] TalkJS auth token will expire and need to be refreshed in ${e2} seconds. Refreshable JWTs are recommended to expire at least 30 minutes in the future, to improve performance and reduce unnecessary refreshes.`) : e2 < 3300 && !t2 && console.warn(`[TalkJS debug] TalkJS will stop working in ${Math.round(e2 / 60)} minutes due to auth token expiry. Non-refreshable tokens are recommended to expire at least 24 hours in the future. Alternatively, provide a \`tokenFetcher\` when creating the session, so that tokens can be refreshed when they expire.`);
    if (void 0 !== this.tokenFetcher) {
      const t3 = e2 > 600 ? e2 - 300 : e2 / 2, s2 = Math.min(1728e6, 1e3 * t3);
      this.sessionExpiryWarningTimeoutId = setTimeout(() => {
        this.refreshToken();
      }, s2);
    } else e2 < 2e6 && (this.sessionExpiryWarningTimeoutId = setTimeout(() => {
      this.emitTokenRefreshFailed("Token has expired and no `tokenFetcher` was provided when creating the session, so it cannot be refreshed.");
    }, 1e3 * e2));
  }
  fetchToken(e2) {
    return __async(this, null, function* () {
      if (this.requestInProgress) return;
      this.requestInProgress = true;
      const t2 = () => __async(this, null, function* () {
        const t3 = yield e2();
        return this.checkJwt(t3), t3;
      });
      try {
        const e3 = void 0 !== this.token;
        this.token = t2(), yield this.token.then((t3) => {
          e3 && this.emitTokenChanged(t3);
        }).catch((e4) => {
          this.emitTokenRefreshFailed(e4);
        });
      } catch (e3) {
        this.emitTokenRefreshFailed(e3);
      } finally {
        this.requestInProgress = false;
      }
    });
  }
  checkJwt(e2) {
    !function(e3) {
      if ("string" == typeof e3 || e3 instanceof String) return;
      if (void 0 === e3) throw "Token was undefined";
      throw "Token must be a string, got: " + e3;
    }(e2);
    const t2 = [];
    let s2, n2, r2;
    if ("string" == typeof e2 ? s2 = e2 : t2.push(`Token type is ${typeof e2} instead of a string.`), s2) try {
      const e3 = function(e4) {
        const t3 = e4.split(".");
        if (3 !== t3.length) throw "Token does not contain exactly two `.`. Check that you generated your JWT correctly. It should be `<header>.<payload>.<signature>`.";
        return { header: Fs(t3[0]), payload: Fs(t3[1]) };
      }(s2);
      n2 = e3.header, r2 = e3.payload;
    } catch (e3) {
      t2.push(e3);
    }
    if (n2) {
      const e3 = this.checkJwtHeader(n2);
      t2.push(...e3);
    }
    if (r2) {
      const e3 = this.checkJwtPayload(r2);
      t2.push(...e3);
    }
    if (t2.length) if (this.usingBokens) Ds.log(`JWT Errors detected by AuthProvider when using bokens: ${t2.join("\n")}`);
    else {
      console.warn("[TalkJS] Authentication token appears to be generated incorrectly. Will still attempt to authenticate, but TalkJS may not work as expected. See below for a description of any problems and how to fix them.");
      const s3 = t2.length > 1;
      t2.forEach((e3, t3) => {
        const n3 = s3 ? `Reason ${t3 + 1}:` : "Reason:";
        console.warn(`[TalkJS] ${n3} ${e3}`);
      }), console.warn(`[TalkJS]: Authentication token: "${e2}"`);
    }
  }
  checkJwtHeader(e2) {
    const t2 = [], s2 = e2.alg;
    return void 0 === s2 ? t2.push('Token header must contain `"alg": "HS256"`, but no `alg` was specified.') : "string" != typeof s2 ? t2.push(`Token header must contain \`"alg": "HS256"\`, but \`alg\` was ${typeof s2} instead of a string. Make sure you wrap the value in "".`) : "HS256" !== s2 && t2.push(`Token header must contain \`"alg": "HS256"\`, but \`alg\` was set to "${s2}" instead. HS256 is the only supported algorithm.`), t2;
  }
  checkJwtPayload(e2) {
    const t2 = [], s2 = e2.iss;
    void 0 === s2 ? t2.push(`Token payload must contain an \`iss\` claim set to your app ID (${this.appId}), but \`iss\` was missing.`) : "string" != typeof s2 ? t2.push(`Token payload must contain an \`iss\` claim set to your app ID (${this.appId}), but \`iss\` was ${typeof s2} instead of a string. Make sure you wrap the value in "".`) : s2 !== this.appId && t2.push(`Token payload must contain an \`iss\` claim set to your app ID (${this.appId}), but \`iss\` was set to "${s2}" instead.`);
    const n2 = e2.sub;
    void 0 === n2 ? t2.push(`Token payload must contain a \`sub\` claim set to your user ID (${this.userId}), but \`sub\` was missing.`) : "string" != typeof n2 ? t2.push(`Token payload must contain a \`sub\` claim set to your user ID (${this.userId}), but \`sub\` was ${typeof n2} instead of a string. Make sure you wrap the value in "".`) : n2 !== this.userId && t2.push(`Token payload must contain a \`sub\` claim set to your userId ID (${this.userId}), but \`sub\` was set to "${n2}" instead.`);
    const r2 = e2.tokenType;
    void 0 === r2 ? t2.push('Token payload must contain a `"tokenType": "user"` claim, but no `tokenType` was specified.') : "string" != typeof r2 ? t2.push(`Token payload must contain a \`"tokenType": "user"\` claim, but \`tokenType\` was ${typeof r2} instead of a string. Make sure you wrap the value in "".`) : "user" !== r2 && t2.push(`Token payload must contain a \`"tokenType": "user"\` claim, but \`tokenType\` was set to "${r2}" instead.`);
    const i2 = e2.exp;
    void 0 === i2 || ("number" != typeof i2 ? t2.push(`Token payload contains an \`exp\` claim, but \`exp\` was ${typeof r2} instead of a number. If set, \`exp\` should be the expiry date as a number of seconds since 1970-01-01. Don't wrap the value in "".`) : i2 < 1e9 ? t2.push(`Token payload contains an \`exp\` claim, but \`exp\` is very small (${i2}, representing ${new Date(1e3 * i2).toLocaleDateString()}). If set, \`exp\` should be the expiry date as a number of seconds since 1970-01-01.`) : i2 > 1e11 ? t2.push(`Token payload contains an \`exp\` claim, but \`exp\` is very small (${i2}, representing ${new Date(1e3 * i2).toLocaleDateString()}). If set, \`exp\` should be the expiry date as a number of seconds since 1970-01-01. Double-check that you are using seconds and not milliseconds or nanoseconds.`) : i2 < (/* @__PURE__ */ new Date()).getTime() / 1e3 && t2.push(`Token payload contains an \`exp\` claim, but \`exp\` (${i2}, representing ${new Date(1e3 * i2).toLocaleDateString()}) appears to be in the past, meaning the token will be rejected. This error can also happen if your device's clock is set incorrectly, in which case the token will still work.`));
    const a2 = e2.nbf;
    return void 0 === a2 || ("number" != typeof a2 ? t2.push(`Token payload contains a \`nbf\` (not-before) claim, but \`nbf\` was ${typeof r2} instead of a number. If set, \`nbf\` should be the date when the JWT becomes valid, as a number of seconds since 1970-01-01.`) : a2 > 1e11 && t2.push(`Token payload contains a \`nbf\` (not-before) claim, but \`nbf\` is very large (${a2}, representing ${new Date(1e3 * a2).toLocaleDateString()}). If set, \`nbf\` should be the date when the JWT becomes valid, as a number of seconds since 1970-01-01. Double-check that you are using seconds and not milliseconds or nanoseconds.`)), t2;
  }
  sendBokenRequest(e2, t2) {
    return __async(this, null, function* () {
      let s2 = 0;
      const n2 = e2.getBokensUrl(this.appId, this.userId, t2), r2 = yield ys({ method: "GET", url: n2, attempts: 1e4, shouldRetry: (e3) => {
        if (e3 instanceof Error) return true;
        if (401 === e3.status) throw "Check that you provided a valid signature.";
        if (404 === e3.status) throw "Check that you specified the correct App ID.";
        if (429 === e3.status || 502 === e3.status) return true;
        if (e3.status >= 400 && e3.status < 500) throw `Unexpected HTTP ${e3.status} response when fetching auth token. Check that you configured the session correctly.`;
        if (s2++, s2 >= 5) throw `Unexpected HTTP ${e3.status} response when fetching auth token, retrying did not help.`;
        return true;
      } });
      return (yield r2.json()).boken;
    });
  }
}
function Fs(e2) {
  try {
    const t2 = e2.replace(/-/g, "+").replace(/_/g, "/"), s2 = decodeURIComponent(atob(t2).split("").map((e3) => "%" + ("00" + e3.charCodeAt(0).toString(16)).slice(-2)).join(""));
    return JSON.parse(s2);
  } catch (t2) {
    throw `Could not base64-decode and JSON-parse token section: ${e2}. Check that you base-64 encoded the section correctly.`;
  }
}
class Bs {
  constructor(e2) {
    this.target = e2;
  }
  deref() {
    return this.target;
  }
}
const Rs = new class {
  constructor() {
    this.registry = {};
  }
  getOrCreate(e2) {
    var _a2;
    const t2 = this.key(e2), s2 = (_a2 = this.registry[t2]) == null ? void 0 : _a2.deref();
    if (s2) return s2;
    const n2 = new _s(e2), r2 = globalThis.WeakRef ? new WeakRef(n2) : new Bs(n2);
    return this.registry[t2] = r2, n2;
  }
  deregister(e2, t2) {
    const s2 = this.key({ appId: e2, userId: t2 });
    delete this.registry[s2];
  }
  key({ appId: e2, userId: t2 }) {
    return `${e2}:${t2}`;
  }
}();
function Ns(e2) {
  if (!e2) throw new Error("[TalkJS] Must provide an options object to `getTalkSession`");
  return e2.forceCreateNew ? new _s(e2) : Rs.getOrCreate(e2);
}
class _s {
  constructor(e2) {
    !function(e3) {
      function t3(e4, t4) {
        if (!e4) throw new Error("[TalkJS] TalkSession: " + t4);
      }
      t3(e3 && "object" == typeof e3, "Expected an object argument in TalkSession#constructor."), t3(e3.appId && "string" == typeof e3.appId, "The `appId` property of TalkSession#constructor is required and it must be a non-empty string."), t3("string" == typeof e3.userId, "The `userId` property of TalkSession#constructor is required and it must be a string."), void 0 !== e3.token && t3(e3.token && "string" == typeof e3.token, "The `token` property of TalkSession#constructor must be a non-empty string.");
      void 0 !== e3.tokenFetcher && t3("function" == typeof e3.tokenFetcher, "The `tokenFetcher` property of TalkSession#constructor must be a function.");
    }(e2);
    const { appId: t2, userId: s2, token: n2, tokenFetcher: r2, signature: i2 } = e2;
    this._appId = t2, this._apiUrls = e2.apiUrls ? new bs(e2.apiUrls.realtimeWsApiUrl, e2.apiUrls.internalHttpApiUrl, e2.apiUrls.restApiHttpUrl) : bs.fromHost(e2.host), this._authProvider = new Ms(this._apiUrls, t2, s2, n2, r2, i2);
    const a2 = Math.random().toString().split(".")[1];
    this._realtimeClient = new Be(this._apiUrls.getRealtimeWsUrl(t2, s2, "1.5.7", a2, e2.clientBuild), s2, this._authProvider), this.currentUser = new _e(this._realtimeClient.userId, this._realtimeClient), this._terminationReason = o(), this._terminationReason.promise.then((e3) => {
      console.error(`[TalkSession] ${e3}`);
    }), function(e3, t3, s3) {
      return __async(this, null, function* () {
        return ys({ method: "GET", url: `${t3}/${e3}/app`, authProvider: s3 }).then((e4) => 200 === e4.status || 404 !== e4.status && (console.warn(`[TalkJS] Received unexpected ${e4.status} status code when validating app ID. Assuming that the app ID is valid.`), true)).catch((e4) => {
          if ("string" != typeof e4 && "status" in e4) {
            const t4 = e4;
            return 200 === t4.status || 404 !== t4.status && (console.warn(`[TalkJS] Received unexpected ${t4.status} status code when validating app ID. Assuming that the app ID is valid.`), true);
          }
          return console.warn("[TalkJS] Encountered network issues when validating app ID. Assuming that the app ID is valid."), true;
        });
      });
    }(this._appId, this._apiUrls.internalHttpApiUrl, this._authProvider).then((e3) => {
      e3 || this.terminate(new Error(`The app ID ${this._appId} does not exist. Make sure you are using the correct app ID as found on the TalkJS dashboard. App IDs are case-sensitive.`));
    }), this._authProvider.onTokenRefreshFailed((e3) => {
      this.terminate(new Error(`Could not authenticate, cannot recover automatically: ${e3}`));
    });
  }
  onError(e2) {
    const t2 = o();
    return Promise.race([t2.promise, this._terminationReason.promise]).then((t3) => {
      "UNSUBSCRIBED" !== t3 && e2(t3);
    }), { unsubscribe: () => t2.resolve("UNSUBSCRIBED") };
  }
  user(e2) {
    if ("string" != typeof e2) throw new Error(`Creating UserRef failed because ID "${e2}" is not a string`);
    if ("" === e2) throw new Error(`Creating UserRef failed because ID "${e2}" is an empty string`);
    return new _e(e2, this._realtimeClient);
  }
  conversation(e2) {
    if ("string" != typeof e2) throw new Error(`Creating ConversationRef failed because ID "${e2}" is not a string`);
    if ("" === e2) throw new Error(`Creating ConversationRef failed because ID "${e2}" is an empty string`);
    return new gs(e2, this._realtimeClient);
  }
  subscribeConversations(e2) {
    return this._realtimeClient.subscribe(["me", "conversations"], e2);
  }
  terminate(e2) {
    Rs.deregister(this._appId, this.currentUser.id), this._terminationReason.resolve(e2), this._realtimeClient.destroy();
  }
  _isConnected() {
    return this._realtimeClient.isConnected();
  }
  uploadFile(e2, t2) {
    return Ps(`${this._apiUrls.restApiHttpUrl}/${this._appId}/files`, this._authProvider, e2, t2);
  }
  uploadImage(e2, t2) {
    return Ps(`${this._apiUrls.restApiHttpUrl}/${this._appId}/files`, this._authProvider, e2, __spreadValues({ subtype: "image" }, t2));
  }
  uploadVideo(e2, t2) {
    return Ps(`${this._apiUrls.restApiHttpUrl}/${this._appId}/files`, this._authProvider, e2, __spreadValues({ subtype: "video" }, t2));
  }
  uploadAudio(e2, t2) {
    return Ps(`${this._apiUrls.restApiHttpUrl}/${this._appId}/files`, this._authProvider, e2, __spreadValues({ subtype: "audio" }, t2));
  }
  uploadVoice(e2, t2) {
    return Ps(`${this._apiUrls.restApiHttpUrl}/${this._appId}/files`, this._authProvider, e2, __spreadValues({ subtype: "voice" }, t2));
  }
}
function Ps(_0, _1, _2, _3) {
  return __async(this, arguments, function* (e2, t2, s2, { subtype: n2, filename: r2, width: i2, height: a2, duration: o2 }) {
    const u2 = new FormData();
    return u2.set("file", s2, r2), void 0 !== n2 && u2.set("subtype", n2), void 0 !== i2 && u2.set("width", i2.toString()), void 0 !== a2 && u2.set("height", a2.toString()), void 0 !== o2 && u2.set("duration", o2.toString()), ys({ method: "POST", url: e2, data: u2, authProvider: t2 }).then((e3) => e3.json()).then((e3) => e3.attachmentToken).catch((e3) => __async(this, null, function* () {
      if (e3 instanceof Response) {
        const t3 = yield e3.json(), s3 = `Unexpected response when uploading file, status code ${e3.status} ${t3.errorCode}, ${t3.reasons}`;
        throw new Error(s3);
      }
      throw e3;
    }));
  });
}
export {
  Ns as getTalkSession,
  f as registerPolyfills
};
//# sourceMappingURL=talkSession.js.map
